# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: stablecoin/tx.proto, stablecoin/events.proto, stablecoin/params.proto, stablecoin/query.proto, stablecoin/genesis.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base import v1beta1


@dataclass
class MsgMintStable(betterproto.Message):
    """
    MsgMintStable: Msg to mint NUSD. A user deposits NIBI and collateral and
    gets NUSD in return. The amount of NUSD received depends on the current
    price set by the oracle library and the current collateral ratio for the
    protocol.
    """

    creator: str = betterproto.string_field(1)
    stable: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class MsgMintStableResponse(betterproto.Message):
    """
    MsgMintStableResponse specifies the amount of NUSD token the user will
    receive after their mint transaction
    """

    stable: v1beta1.Coin = betterproto.message_field(1)
    used_coins: List[v1beta1.Coin] = betterproto.message_field(2)
    fees_payed: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class MsgBurnStable(betterproto.Message):
    """
    MsgBurnStable allows users to burn NUSD in exchange for NIBI and
    collateral. The amount of NIBI and Collateral received depends on the
    current price set by the x/oracle library and the current collateral ratio.
    """

    creator: str = betterproto.string_field(1)
    stable: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class MsgBurnStableResponse(betterproto.Message):
    """
    MsgBurnStableResponse specifies the amount of collateral and governance
    token the user will receive after their burn transaction.
    """

    collateral: v1beta1.Coin = betterproto.message_field(1)
    gov: v1beta1.Coin = betterproto.message_field(2)
    fees_payed: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class MsgRecollateralize(betterproto.Message):
    """MsgRecollateralize"""

    creator: str = betterproto.string_field(1)
    coll: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class MsgRecollateralizeResponse(betterproto.Message):
    """
    MsgRecollateralizeResponse is the output of a successful 'Recollateralize'
    """

    # Gov (sdk.Coin): Tokens rewarded to the caller in exchange for her
    # collateral.
    gov: v1beta1.Coin = betterproto.message_field(1)


@dataclass
class MsgBuyback(betterproto.Message):
    """MsgBuyback"""

    creator: str = betterproto.string_field(1)
    # Gov (sdk.Coin): Tokens the caller wants to sell to the protocol in exchange
    # for collateral.
    gov: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class MsgBuybackResponse(betterproto.Message):
    """MsgBuybackResponse is the output of a successful 'Buyback'"""

    # Coll (sdk.Coin): Tokens sold to the caller in exchange for her collateral.
    coll: v1beta1.Coin = betterproto.message_field(1)


@dataclass
class EventTransfer(betterproto.Message):
    coin: v1beta1.Coin = betterproto.message_field(1)
    from_: str = betterproto.string_field(2)
    to: str = betterproto.string_field(3)


@dataclass
class EventMintStable(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass
class EventBurnStable(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass
class EventMintNIBI(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass
class EventBurnNIBI(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass
class EventRecollateralize(betterproto.Message):
    caller: str = betterproto.string_field(1)
    in_coin: v1beta1.Coin = betterproto.message_field(2)
    out_coin: v1beta1.Coin = betterproto.message_field(3)
    coll_ratio: str = betterproto.string_field(4)


@dataclass
class EventBuyback(betterproto.Message):
    caller: str = betterproto.string_field(1)
    in_coin: v1beta1.Coin = betterproto.message_field(2)
    out_coin: v1beta1.Coin = betterproto.message_field(3)
    coll_ratio: str = betterproto.string_field(4)


@dataclass
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    # collRatio is the ratio needed as collateral to exchange for stables
    coll_ratio: int = betterproto.int64_field(1)
    # feeRatio is the ratio taken as fees when minting or burning stables
    fee_ratio: int = betterproto.int64_field(2)
    # efFeeRatio is the ratio taken from the fees that goes to Ecosystem Fund
    ef_fee_ratio: int = betterproto.int64_field(3)
    # BonusRateRecoll is the percentage of extra stablecoin value given to the
    # callerof 'Recollateralize' in units of governance tokens.
    bonus_rate_recoll: int = betterproto.int64_field(4)
    # distr_epoch_identifier defines the frequnecy of update for the collateral
    # ratio
    distr_epoch_identifier: str = betterproto.string_field(5)
    # adjustmentStep is the size of the step taken when updating the collateral
    # ratio
    adjustment_step: int = betterproto.int64_field(6)
    # priceLowerBound is the lower bound for the stable coin to trigger a
    # collateral ratio update
    price_lower_bound: int = betterproto.int64_field(7)
    # priceUpperBound is the upper bound for the stable coin to trigger a
    # collateral ratio update
    price_upper_bound: int = betterproto.int64_field(8)
    # isCollateralRatioValid checks if the collateral ratio is correctly updated
    is_collateral_ratio_valid: bool = betterproto.bool_field(9)


@dataclass
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    # params holds all the parameters of this module.
    params: "Params" = betterproto.message_field(1)


@dataclass
class QueryModuleAccountBalances(betterproto.Message):
    """
    QueryModuleAccountBalances is the request type for the balance of the
    x/stablecoin module account.
    """

    pass


@dataclass
class QueryModuleAccountBalancesResponse(betterproto.Message):
    # ModuleAccountBalances is the balance of all coins in the x/stablecoin
    # module.
    module_account_balances: List[v1beta1.Coin] = betterproto.message_field(1)


@dataclass
class QueryCirculatingSupplies(betterproto.Message):
    """
    QueryCirculatingSupplies is the request type for the circulating supply
    ofboth NIBI and NUSD.
    """

    pass


@dataclass
class QueryCirculatingSuppliesResponse(betterproto.Message):
    nibi: v1beta1.Coin = betterproto.message_field(1)
    nusd: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class QueryGovToMintStable(betterproto.Message):
    """
    QueryGovToMintStable is the request type for the Query/GovToMintStable RPC
    method
    """

    collateral: v1beta1.Coin = betterproto.message_field(1)


@dataclass
class QueryGovToMintStableResponse(betterproto.Message):
    """
    QueryGovToMintStableResponse is the response type for
    'QueryGovToMintStable'
    """

    gov: v1beta1.Coin = betterproto.message_field(1)


@dataclass
class LiquidityRatioInfo(betterproto.Message):
    liquidity_ratio: str = betterproto.string_field(1)
    upper_band: str = betterproto.string_field(2)
    lower_band: str = betterproto.string_field(3)


@dataclass
class QueryLiquidityRatioInfoRequest(betterproto.Message):
    pass


@dataclass
class QueryLiquidityRatioInfoResponse(betterproto.Message):
    info: "LiquidityRatioInfo" = betterproto.message_field(1)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState defines the stablecoin module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    module_account_balance: v1beta1.Coin = betterproto.message_field(2)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the x/stablecoin Msg service."""

    async def mint_stable(
        self, *, creator: str = "", stable: Optional[v1beta1.Coin] = None
    ) -> MsgMintStableResponse:
        """
        MintStable defines a method for trading a mixture of GOV and COLL to
        mint an equivalent value of stablecoins.
        """

        request = MsgMintStable()
        request.creator = creator
        if stable is not None:
            request.stable = stable

        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Msg/MintStable",
            request,
            MsgMintStableResponse,
        )

    async def burn_stable(
        self, *, creator: str = "", stable: Optional[v1beta1.Coin] = None
    ) -> MsgBurnStableResponse:
        """
        BurnStable defines a method for redeeming/burning stablecoins to
        receive an equivalent value as a mixture of governance and collateral
        tokens.
        """

        request = MsgBurnStable()
        request.creator = creator
        if stable is not None:
            request.stable = stable

        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Msg/BurnStable",
            request,
            MsgBurnStableResponse,
        )

    async def recollateralize(
        self, *, creator: str = "", coll: Optional[v1beta1.Coin] = None
    ) -> MsgRecollateralizeResponse:
        """
        Recollateralize defines a method for manually adding collateral to the
        protocol in exchange for an equivalent stablecoin value in governance
        tokens plus a small bonus.
        """

        request = MsgRecollateralize()
        request.creator = creator
        if coll is not None:
            request.coll = coll

        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Msg/Recollateralize",
            request,
            MsgRecollateralizeResponse,
        )

    async def buyback(
        self, *, creator: str = "", gov: Optional[v1beta1.Coin] = None
    ) -> MsgBuybackResponse:
        """
        Buyback defines a method for manually adding NIBI to the protocol in
        exchange for an equivalent stablecoin value in collateral, effectively
        executing a share buyback for Nibiru Chain. The NIBI purchased by the
        protocol is then burned, distributing value to all NIBI hodlers.
        """

        request = MsgBuyback()
        request.creator = creator
        if gov is not None:
            request.gov = gov

        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Msg/Buyback",
            request,
            MsgBuybackResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query defines the gRPC querier service."""

    async def params(self) -> QueryParamsResponse:
        """Parameters queries the parameters of the x/stablecoin module."""

        request = QueryParamsRequest()

        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Query/Params",
            request,
            QueryParamsResponse,
        )

    async def module_account_balances(self) -> QueryModuleAccountBalancesResponse:
        """
        ModuleAccountBalances queries the account balance of x/stablecoin.
        """

        request = QueryModuleAccountBalances()

        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Query/ModuleAccountBalances",
            request,
            QueryModuleAccountBalancesResponse,
        )

    async def circulating_supplies(self) -> QueryCirculatingSuppliesResponse:
        request = QueryCirculatingSupplies()

        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Query/CirculatingSupplies",
            request,
            QueryCirculatingSuppliesResponse,
        )

    async def liquidity_ratio_info(self) -> QueryLiquidityRatioInfoResponse:
        request = QueryLiquidityRatioInfoRequest()

        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Query/LiquidityRatioInfo",
            request,
            QueryLiquidityRatioInfoResponse,
        )
