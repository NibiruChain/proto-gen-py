# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: perp/v1/state.proto, perp/v1/tx.proto, perp/v1/query.proto, perp/v1/event.proto, perp/v1/genesis.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base import v1beta1
from .nibiru import common


class Side(betterproto.Enum):
    SIDE_UNSPECIFIED = 0
    BUY = 1
    SELL = 2


class PnLCalcOption(betterproto.Enum):
    PNL_CALC_OPTION_UNSPECIFIED = 0
    SPOT_PRICE = 1
    TWAP = 2
    ORACLE = 3


class PnLPreferenceOption(betterproto.Enum):
    PNL_PREFERENCE_UNSPECIFIED = 0
    MAX = 1
    MIN = 2


class MarginCalculationPriceOption(betterproto.Enum):
    MARGIN_CALCULATION_PRICE_OPTION_UNSPECIFIED = 0
    SPOT = 1
    INDEX = 2
    MAX_PNL = 3


@dataclass
class Params(betterproto.Message):
    # stopped identifies if the perp exchange is stopped or not
    stopped: bool = betterproto.bool_field(1)
    # FeePoolFeeRatio is the ratio transferred to the the fee pool
    fee_pool_fee_ratio: str = betterproto.string_field(3)
    # EcosystemFundFeeRatio is the ratio transferred to the PerpEF.
    ecosystem_fund_fee_ratio: str = betterproto.string_field(4)
    # LiquidationFeeRatio is the percentage of liquidated position that will be
    # given to out as a reward. Half of the liquidation fee is given to the
    # liquidator, and the other half is given to the ecosystem fund.
    liquidation_fee_ratio: str = betterproto.string_field(5)
    # PartialLiquidationRatio is the share we try to liquidate if the margin is
    # higher than liquidation fee
    partial_liquidation_ratio: str = betterproto.string_field(6)
    # specifies the interval on which the funding rate is updated
    funding_rate_interval: str = betterproto.string_field(7)
    # amount of time to look back for TWAP calculations
    twap_lookback_window: timedelta = betterproto.message_field(8)
    # whitelisted_liquidators defines the list of addresses which are allowed to
    # liquidate a position.
    whitelisted_liquidators: List[str] = betterproto.string_field(9)


@dataclass
class Position(betterproto.Message):
    """
    Position identifies and records information on a user's position on one of
    the virtual liquidity pools.
    """

    # address identifies the address owner of this position
    trader_address: str = betterproto.string_field(1)
    # pair identifies the pair associated with this position
    pair: common.AssetPair = betterproto.message_field(2)
    # Position size.
    size: str = betterproto.string_field(3)
    # Amount of margin remaining in the position.
    margin: str = betterproto.string_field(4)
    # OpenNotional is the quote denom value of the position when opening. Used to
    # calculate PnL.
    open_notional: str = betterproto.string_field(5)
    # The most recent cumulative premium fraction this position has. Used to
    # calculate the next funding payment.
    latest_cumulative_premium_fraction: str = betterproto.string_field(6)
    # BlockNumber is the last block number when this position was updated.
    block_number: int = betterproto.int64_field(7)


@dataclass
class PairMetadata(betterproto.Message):
    pair: common.AssetPair = betterproto.message_field(1)
    # Latest cumulative premium fraction for a given pair. Calculated once per
    # funding rate interval. A premium fraction is the difference between mark
    # and index, divided by the number of payments per day. (mark - index) / #
    # payments in a day
    latest_cumulative_premium_fraction: str = betterproto.string_field(2)


@dataclass
class PrepaidBadDebt(betterproto.Message):
    denom: str = betterproto.string_field(1)
    amount: str = betterproto.string_field(2)


@dataclass
class PositionResp(betterproto.Message):
    position: "Position" = betterproto.message_field(1)
    # The amount of quote assets exchanged.
    exchanged_notional_value: str = betterproto.string_field(2)
    # The amount of base assets exchanged.
    exchanged_position_size: str = betterproto.string_field(3)
    # The amount of bad debt accrued during this position change. Measured in
    # absolute value of quote units. If greater than zero, then the position
    # change event will likely fail.
    bad_debt: str = betterproto.string_field(4)
    # The funding payment applied on this position change.
    funding_payment: str = betterproto.string_field(5)
    # The amount of PnL realized on this position changed, measured in quote
    # units.
    realized_pnl: str = betterproto.string_field(6)
    # The unrealized PnL in the position after the position change.
    unrealized_pnl_after: str = betterproto.string_field(7)
    # The amount of margin the trader has to give to the vault. A negative value
    # means the vault pays the trader.
    margin_to_vault: str = betterproto.string_field(8)
    # The position's notional value after the position change, measured in quote
    # units.
    position_notional: str = betterproto.string_field(9)


@dataclass
class LiquidateResp(betterproto.Message):
    # Amount of bad debt created by the liquidation event
    bad_debt: str = betterproto.string_field(1)
    # Fee paid to the liquidator
    fee_to_liquidator: str = betterproto.string_field(2)
    # Fee paid to the Perp EF fund
    fee_to_perp_ecosystem_fund: str = betterproto.string_field(3)
    # Address of the liquidator
    liquidator: str = betterproto.string_field(4)
    # Position response from the close or open reverse position
    position_resp: "PositionResp" = betterproto.message_field(5)


@dataclass
class Metrics(betterproto.Message):
    """
    PoolMetrics is a structure that displays a snapshot of perp metrics for
    each pair.
    """

    # Pair identifier for the two assets. Always in format 'base:quote'
    pair: str = betterproto.string_field(1)
    # Sum of all active position sizes for the pair.
    net_size: str = betterproto.string_field(2)
    # Total notional volume for the pair.
    volume_quote: str = betterproto.string_field(3)
    # Total size volume for the pair.
    volume_base: str = betterproto.string_field(4)


@dataclass
class MsgRemoveMargin(betterproto.Message):
    """MsgRemoveMargin: Msg to remove margin."""

    sender: str = betterproto.string_field(1)
    token_pair: str = betterproto.string_field(2)
    margin: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class MsgRemoveMarginResponse(betterproto.Message):
    # tokens transferred back to the trader
    margin_out: v1beta1.Coin = betterproto.message_field(1)
    # the funding payment applied on this position interaction
    funding_payment: str = betterproto.string_field(2)
    # The resulting position
    position: "Position" = betterproto.message_field(3)


@dataclass
class MsgAddMargin(betterproto.Message):
    """MsgAddMargin: Msg to remove margin."""

    sender: str = betterproto.string_field(1)
    token_pair: str = betterproto.string_field(2)
    margin: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class MsgAddMarginResponse(betterproto.Message):
    funding_payment: str = betterproto.string_field(1)
    position: "Position" = betterproto.message_field(2)


@dataclass
class MsgLiquidate(betterproto.Message):
    # Sender is the liquidator address
    sender: str = betterproto.string_field(1)
    # TokenPair is the identifier for the position's virtual pool
    token_pair: str = betterproto.string_field(2)
    # Trader is the address of the owner of the position
    trader: str = betterproto.string_field(3)


@dataclass
class MsgLiquidateResponse(betterproto.Message):
    fee_to_liquidator: v1beta1.Coin = betterproto.message_field(1)
    fee_to_perp_ecosystem_fund: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class MsgMultiLiquidate(betterproto.Message):
    sender: str = betterproto.string_field(1)
    liquidations: List["MsgMultiLiquidateMultiLiquidation"] = betterproto.message_field(
        2
    )


@dataclass
class MsgMultiLiquidateMultiLiquidation(betterproto.Message):
    token_pair: str = betterproto.string_field(2)
    trader: str = betterproto.string_field(3)


@dataclass
class MsgMultiLiquidateResponse(betterproto.Message):
    liquidation_responses: List[
        "MsgMultiLiquidateResponseMultiLiquidateResponse"
    ] = betterproto.message_field(1)


@dataclass
class MsgMultiLiquidateResponseMultiLiquidateResponse(betterproto.Message):
    error: str = betterproto.string_field(1, group="response")
    liquidation: "MsgLiquidateResponse" = betterproto.message_field(2, group="response")


@dataclass
class MsgOpenPosition(betterproto.Message):
    sender: str = betterproto.string_field(1)
    token_pair: str = betterproto.string_field(2)
    side: "Side" = betterproto.enum_field(3)
    quote_asset_amount: str = betterproto.string_field(4)
    leverage: str = betterproto.string_field(5)
    base_asset_amount_limit: str = betterproto.string_field(6)


@dataclass
class MsgOpenPositionResponse(betterproto.Message):
    position: "Position" = betterproto.message_field(1)
    # The amount of quote assets exchanged.
    exchanged_notional_value: str = betterproto.string_field(2)
    # The amount of base assets exchanged.
    exchanged_position_size: str = betterproto.string_field(3)
    # The funding payment applied on this position change, measured in quote
    # units.
    funding_payment: str = betterproto.string_field(4)
    # The amount of PnL realized on this position changed, measured in quote
    # units.
    realized_pnl: str = betterproto.string_field(5)
    # The unrealized PnL in the position after the position change, measured in
    # quote units.
    unrealized_pnl_after: str = betterproto.string_field(6)
    # The amount of margin the trader has to give to the vault. A negative value
    # means the vault pays the trader.
    margin_to_vault: str = betterproto.string_field(7)
    # The position's notional value after the position change, measured in quote
    # units.
    position_notional: str = betterproto.string_field(8)


@dataclass
class MsgClosePosition(betterproto.Message):
    sender: str = betterproto.string_field(1)
    token_pair: str = betterproto.string_field(2)


@dataclass
class MsgClosePositionResponse(betterproto.Message):
    # The amount of quote assets exchanged.
    exchanged_notional_value: str = betterproto.string_field(1)
    # The amount of base assets exchanged.
    exchanged_position_size: str = betterproto.string_field(2)
    # The funding payment applied on this position change, measured in quote
    # units.
    funding_payment: str = betterproto.string_field(3)
    # The amount of PnL realized on this position changed, measured in quote
    # units.
    realized_pnl: str = betterproto.string_field(4)
    # The amount of margin the trader receives after closing the position, from
    # the vault. Should never be negative.
    margin_to_trader: str = betterproto.string_field(7)


@dataclass
class MsgDonateToEcosystemFund(betterproto.Message):
    sender: str = betterproto.string_field(1)
    # donation to the EF
    donation: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class MsgDonateToEcosystemFundResponse(betterproto.Message):
    pass


@dataclass
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    # params holds all the parameters of this module.
    params: "Params" = betterproto.message_field(1)


@dataclass
class QueryPositionsRequest(betterproto.Message):
    """---------------------------------------- Positions"""

    trader: str = betterproto.string_field(1)


@dataclass
class QueryPositionsResponse(betterproto.Message):
    positions: List["QueryPositionResponse"] = betterproto.message_field(1)


@dataclass
class QueryPositionRequest(betterproto.Message):
    """
    QueryPositionRequest is the request type for the position of the x/perp
    module account.
    """

    token_pair: str = betterproto.string_field(1)
    trader: str = betterproto.string_field(2)


@dataclass
class QueryPositionResponse(betterproto.Message):
    # The position as it exists in the blockchain state
    position: "Position" = betterproto.message_field(1)
    # The position's current notional value, if it were to be entirely closed (in
    # margin units).
    position_notional: str = betterproto.string_field(2)
    # The position's unrealized PnL.
    unrealized_pnl: str = betterproto.string_field(3)
    # margin ratio of the position based on the mark price, mark TWAP. The higher
    # value of the possible margin ratios (TWAP and instantaneous) is taken to be
    # 'marginRatioMark'. Calculated from margin, unrealized PnL, and position
    # notional.
    margin_ratio_mark: str = betterproto.string_field(4)
    # margin ratio of the position based on the index price. Calculated from
    # margin, unrealized PnL, and position notional.
    margin_ratio_index: str = betterproto.string_field(5)
    # BlockNumber is current block number at the time of query.
    block_number: int = betterproto.int64_field(7)


@dataclass
class QueryCumulativePremiumFractionRequest(betterproto.Message):
    # the pair to query for
    pair: str = betterproto.string_field(1)


@dataclass
class QueryCumulativePremiumFractionResponse(betterproto.Message):
    # The latest cumulative premium fraction.
    cumulative_premium_fraction: str = betterproto.string_field(1)
    estimated_next_cumulative_premium_fraction: str = betterproto.string_field(2)


@dataclass
class QueryMetricsRequest(betterproto.Message):
    # the pair to query for
    pair: str = betterproto.string_field(1)


@dataclass
class QueryMetricsResponse(betterproto.Message):
    # list of perp metrics
    metrics: "Metrics" = betterproto.message_field(1)


@dataclass
class PositionChangedEvent(betterproto.Message):
    """
    Emitted when a position changes. TODO: Is there a way to split this into
    different events without creating too much complexity?
    """

    # identifier of the corresponding virtual pool for the position
    pair: str = betterproto.string_field(1)
    # owner of the position.
    trader_address: str = betterproto.string_field(2)
    # Amount of collateral (quote units) backing the position after the change.
    margin: v1beta1.Coin = betterproto.message_field(3)
    # Position notional (quote units) after the change. In general,  'notional =
    # baseAmount * priceQuotePerBase', where size is the baseAmount.
    position_notional: str = betterproto.string_field(4)
    # Exchanged size is the magnitude of the change to position size (base
    # units).  The size is a signed quantity expressing how much exposure a
    # position has in  base units of the pair.
    exchanged_size: str = betterproto.string_field(5)
    # * Exchanged notional is the value of the exchanged size in quote units.
    # exchangedNotional = posBefore.OpenNotional + (direction * realizedPnl),
    # where 'posBefore' is the position before the change, and  direction is 1 if
    # posBefore.Size > 0 or -1 if posBefore.Size < 0,
    exchanged_notional: str = betterproto.string_field(6)
    # Transaction fee paid. A "taker" fee.
    transaction_fee: v1beta1.Coin = betterproto.message_field(7)
    # Position size after the change.
    position_size: str = betterproto.string_field(8)
    # realize profits and losses after the change
    realized_pnl: str = betterproto.string_field(9)
    # unrealized profits and losses after the change
    unrealized_pnl_after: str = betterproto.string_field(10)
    # Amount of bad debt cleared by the PerpEF during the change.  Bad debt is
    # negative net margin past the liquidation point of a position.
    bad_debt: v1beta1.Coin = betterproto.message_field(11)
    # Mark price, synonymous with mark price in this context, is the quotient of
    # the quote reserves and base reserves
    mark_price: str = betterproto.string_field(12)
    # A funding payment made or received by the trader on the current position.
    # 'fundingPayment' is positive if 'owner' is the sender and negative if
    # 'owner'is the receiver of the payment. Its magnitude is abs(vSize *
    # fundingRate). Funding payments act to converge the mark price (vPrice) and
    # index price (average price on major exchanges).
    funding_payment: str = betterproto.string_field(13)
    # The block number at which this position was changed.
    block_height: int = betterproto.int64_field(14)
    # The block time in unix milliseconds at which this position was changed.
    block_time_ms: int = betterproto.int64_field(15)


@dataclass
class PositionLiquidatedEvent(betterproto.Message):
    """Emitted when a position is liquidated."""

    # identifier of the corresponding virtual pool for the position
    pair: str = betterproto.string_field(1)
    # owner of the position.
    trader_address: str = betterproto.string_field(2)
    # margin * leverage * vPrice. 'notional' is the virtual size times  the
    # virtual price on 'vpool'.
    exchanged_quote_amount: str = betterproto.string_field(3)
    # virtual amount of base assets for the position, which would be margin *
    # leverage * priceBasePerQuote.
    exchanged_position_size: str = betterproto.string_field(4)
    # Address of the account that executed the tx.
    liquidator_address: str = betterproto.string_field(5)
    # Commission (in margin units) received by 'liquidator'.
    fee_to_liquidator: v1beta1.Coin = betterproto.message_field(6)
    # Commission (in margin units) given to the ecosystem fund.
    fee_to_ecosystem_fund: v1beta1.Coin = betterproto.message_field(7)
    # Bad debt (margin units) cleared by the PerpEF during the tx. Bad debt is
    # negative net margin past the liquidation point of a position.
    bad_debt: v1beta1.Coin = betterproto.message_field(8)
    # Remaining margin in the position after liquidation
    margin: v1beta1.Coin = betterproto.message_field(9)
    # Remaining position notional in the position after liquidation
    position_notional: str = betterproto.string_field(10)
    # Remaining position size in the position after liquidation
    position_size: str = betterproto.string_field(11)
    # Unrealized PnL in the position after liquidation
    unrealized_pnl: str = betterproto.string_field(12)
    # Spot price of the vAMM after liquidation
    mark_price: str = betterproto.string_field(13)
    # The block number at which this liquidation occured.
    block_height: int = betterproto.int64_field(14)
    # The unix timestamp in milliseconds at which this liquidation occured.
    block_time_ms: int = betterproto.int64_field(15)


@dataclass
class PositionSettledEvent(betterproto.Message):
    """Emitted when a position is settled."""

    # Identifier for the virtual pool of the position.
    pair: str = betterproto.string_field(1)
    # Owner of the position.
    trader_address: str = betterproto.string_field(2)
    # Settled coin as dictated by the settlement price of the vpool.
    settled_coins: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class FundingRateChangedEvent(betterproto.Message):
    """Emitted when a new funding rate is calculated."""

    # The pair for which the funding rate was calculated.
    pair: str = betterproto.string_field(1)
    # The mark price of the pair.
    mark_price: str = betterproto.string_field(2)
    # The oracle index price of the pair.
    index_price: str = betterproto.string_field(3)
    # The latest funding rate.
    latest_funding_rate: str = betterproto.string_field(4)
    # The latest premium fraction just calculated.
    latest_premium_fraction: str = betterproto.string_field(5)
    # The latest cumulative premium fraction. The funding payment a position will
    # pay is the difference between this value and the latest cumulative premium
    # fraction on the position, multiplied by the position size.
    cumulative_premium_fraction: str = betterproto.string_field(6)
    # The block number at which the funding rate was calculated.
    block_height: int = betterproto.int64_field(7)
    # The block time in unix milliseconds at which the funding rate was
    # calculated.
    block_time_ms: int = betterproto.int64_field(8)


@dataclass
class MetricsEvent(betterproto.Message):
    pair: str = betterproto.string_field(1)
    # Sum of all active position sizes for the pair.
    net_size: str = betterproto.string_field(2)
    # Total notional volume for the pair.
    volume_quote: str = betterproto.string_field(3)
    # Total size volume for the pair.
    volume_base: str = betterproto.string_field(4)
    # The block number at which metrics were generated.
    block_height: int = betterproto.int64_field(5)
    # The block time in unix milliseconds at which metrics were generated.
    block_time_ms: int = betterproto.int64_field(6)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState defines the perp module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    pair_metadata: List["PairMetadata"] = betterproto.message_field(2)
    positions: List["Position"] = betterproto.message_field(3)
    prepaid_bad_debts: List["PrepaidBadDebt"] = betterproto.message_field(4)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the x/perp Msg service."""

    async def remove_margin(
        self,
        *,
        sender: str = "",
        token_pair: str = "",
        margin: Optional[v1beta1.Coin] = None,
    ) -> MsgRemoveMarginResponse:
        request = MsgRemoveMargin()
        request.sender = sender
        request.token_pair = token_pair
        if margin is not None:
            request.margin = margin

        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/RemoveMargin",
            request,
            MsgRemoveMarginResponse,
        )

    async def add_margin(
        self,
        *,
        sender: str = "",
        token_pair: str = "",
        margin: Optional[v1beta1.Coin] = None,
    ) -> MsgAddMarginResponse:
        request = MsgAddMargin()
        request.sender = sender
        request.token_pair = token_pair
        if margin is not None:
            request.margin = margin

        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/AddMargin",
            request,
            MsgAddMarginResponse,
        )

    async def liquidate(
        self, *, sender: str = "", token_pair: str = "", trader: str = ""
    ) -> MsgLiquidateResponse:
        """
        Liquidate is a transaction that allows the caller to fully or partially
        liquidate an existing position.
        """

        request = MsgLiquidate()
        request.sender = sender
        request.token_pair = token_pair
        request.trader = trader

        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/Liquidate",
            request,
            MsgLiquidateResponse,
        )

    async def multi_liquidate(
        self,
        *,
        sender: str = "",
        liquidations: List["MsgMultiLiquidateMultiLiquidation"] = [],
    ) -> MsgMultiLiquidateResponse:
        request = MsgMultiLiquidate()
        request.sender = sender
        if liquidations is not None:
            request.liquidations = liquidations

        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/MultiLiquidate",
            request,
            MsgMultiLiquidateResponse,
        )

    async def open_position(
        self,
        *,
        sender: str = "",
        token_pair: str = "",
        side: "Side" = 0,
        quote_asset_amount: str = "",
        leverage: str = "",
        base_asset_amount_limit: str = "",
    ) -> MsgOpenPositionResponse:
        request = MsgOpenPosition()
        request.sender = sender
        request.token_pair = token_pair
        request.side = side
        request.quote_asset_amount = quote_asset_amount
        request.leverage = leverage
        request.base_asset_amount_limit = base_asset_amount_limit

        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/OpenPosition",
            request,
            MsgOpenPositionResponse,
        )

    async def close_position(
        self, *, sender: str = "", token_pair: str = ""
    ) -> MsgClosePositionResponse:
        request = MsgClosePosition()
        request.sender = sender
        request.token_pair = token_pair

        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/ClosePosition",
            request,
            MsgClosePositionResponse,
        )

    async def donate_to_ecosystem_fund(
        self, *, sender: str = "", donation: Optional[v1beta1.Coin] = None
    ) -> MsgDonateToEcosystemFundResponse:
        request = MsgDonateToEcosystemFund()
        request.sender = sender
        if donation is not None:
            request.donation = donation

        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/DonateToEcosystemFund",
            request,
            MsgDonateToEcosystemFundResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query defines the gRPC querier service."""

    async def params(self) -> QueryParamsResponse:
        """Parameters queries the parameters of the x/perp module."""

        request = QueryParamsRequest()

        return await self._unary_unary(
            "/nibiru.perp.v1.Query/Params",
            request,
            QueryParamsResponse,
        )

    async def query_position(
        self, *, token_pair: str = "", trader: str = ""
    ) -> QueryPositionResponse:
        request = QueryPositionRequest()
        request.token_pair = token_pair
        request.trader = trader

        return await self._unary_unary(
            "/nibiru.perp.v1.Query/QueryPosition",
            request,
            QueryPositionResponse,
        )

    async def query_positions(self, *, trader: str = "") -> QueryPositionsResponse:
        request = QueryPositionsRequest()
        request.trader = trader

        return await self._unary_unary(
            "/nibiru.perp.v1.Query/QueryPositions",
            request,
            QueryPositionsResponse,
        )

    async def cumulative_premium_fraction(
        self, *, pair: str = ""
    ) -> QueryCumulativePremiumFractionResponse:
        """
        Queries the latest cumulative premium fraction and the estimated next
        cumulative premium fraction.
        """

        request = QueryCumulativePremiumFractionRequest()
        request.pair = pair

        return await self._unary_unary(
            "/nibiru.perp.v1.Query/CumulativePremiumFraction",
            request,
            QueryCumulativePremiumFractionResponse,
        )

    async def metrics(self, *, pair: str = "") -> QueryMetricsResponse:
        request = QueryMetricsRequest()
        request.pair = pair

        return await self._unary_unary(
            "/nibiru.perp.v1.Query/Metrics",
            request,
            QueryMetricsResponse,
        )
