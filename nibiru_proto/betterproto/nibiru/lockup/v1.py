# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: lockup/v1/lock.proto, lockup/v1/tx.proto, lockup/v1/query.proto, lockup/v1/genesis.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base import v1beta1
from .cosmos.base.query import v1beta1


@dataclass
class Lock(betterproto.Message):
    """
    Lock represents a users locked tokens for a period of time. It stores
    owner, duration, unlock time and the amount of coins locked.
    """

    # unique autoincrementing numeric lock id
    lock_id: int = betterproto.uint64_field(1)
    # the user's address who owns the tokens that are locked
    owner: str = betterproto.string_field(2)
    # the duration that the lock is locked for
    duration: timedelta = betterproto.message_field(3)
    # when the lock was unlocked
    end_time: datetime = betterproto.message_field(4)
    # the coins locked in this Lock
    coins: List[v1beta1.Coin] = betterproto.message_field(5)


@dataclass
class MsgLockTokens(betterproto.Message):
    owner: str = betterproto.string_field(1)
    duration: timedelta = betterproto.message_field(2)
    coins: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class MsgLockTokensResponse(betterproto.Message):
    lock_id: int = betterproto.uint64_field(1)


@dataclass
class MsgInitiateUnlock(betterproto.Message):
    owner: str = betterproto.string_field(1)
    lock_id: int = betterproto.uint64_field(2)


@dataclass
class MsgInitiateUnlockResponse(betterproto.Message):
    pass


@dataclass
class MsgUnlock(betterproto.Message):
    owner: str = betterproto.string_field(1)
    lock_id: int = betterproto.uint64_field(2)


@dataclass
class MsgUnlockResponse(betterproto.Message):
    pass


@dataclass
class EventLock(betterproto.Message):
    lock_id: int = betterproto.uint64_field(1)
    owner: str = betterproto.string_field(2)
    duration: timedelta = betterproto.message_field(3)
    coins: List[v1beta1.Coin] = betterproto.message_field(4)


@dataclass
class EventUnlockInitiated(betterproto.Message):
    lock_id: int = betterproto.uint64_field(1)
    owner: str = betterproto.string_field(2)
    coins: List[v1beta1.Coin] = betterproto.message_field(3)
    unlocking_at: datetime = betterproto.message_field(4)


@dataclass
class EventUnlock(betterproto.Message):
    lock_id: int = betterproto.uint64_field(1)
    owner: str = betterproto.string_field(2)
    coins: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class QueryLockedCoinsRequest(betterproto.Message):
    address: str = betterproto.string_field(1)


@dataclass
class QueryLockedCoinsResponse(betterproto.Message):
    locked_coins: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class QueryLockRequest(betterproto.Message):
    id: int = betterproto.uint64_field(1)


@dataclass
class QueryLockResponse(betterproto.Message):
    lock: "Lock" = betterproto.message_field(1)


@dataclass
class QueryLocksByAddress(betterproto.Message):
    address: str = betterproto.string_field(1)
    pagination: v1beta1.PageRequest = betterproto.message_field(2)


@dataclass
class QueryLocksByAddressResponse(betterproto.Message):
    locks: List["Lock"] = betterproto.message_field(1)
    pagination: v1beta1.PageResponse = betterproto.message_field(2)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState defines the lockup module's genesis state."""

    locks: List["Lock"] = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the Msg service."""

    async def lock_tokens(
        self,
        *,
        owner: str = "",
        duration: Optional[timedelta] = None,
        coins: List[v1beta1.Coin] = [],
    ) -> MsgLockTokensResponse:
        """LockTokens lock tokens"""

        request = MsgLockTokens()
        request.owner = owner
        if duration is not None:
            request.duration = duration
        if coins is not None:
            request.coins = coins

        return await self._unary_unary(
            "/nibiru.lockup.v1.Msg/LockTokens",
            request,
            MsgLockTokensResponse,
        )

    async def initiate_unlock(
        self, *, owner: str = "", lock_id: int = 0
    ) -> MsgInitiateUnlockResponse:
        request = MsgInitiateUnlock()
        request.owner = owner
        request.lock_id = lock_id

        return await self._unary_unary(
            "/nibiru.lockup.v1.Msg/InitiateUnlock",
            request,
            MsgInitiateUnlockResponse,
        )

    async def unlock(self, *, owner: str = "", lock_id: int = 0) -> MsgUnlockResponse:
        request = MsgUnlock()
        request.owner = owner
        request.lock_id = lock_id

        return await self._unary_unary(
            "/nibiru.lockup.v1.Msg/Unlock",
            request,
            MsgUnlockResponse,
        )


class QueryStub(betterproto.ServiceStub):
    async def locked_coins(self, *, address: str = "") -> QueryLockedCoinsResponse:
        request = QueryLockedCoinsRequest()
        request.address = address

        return await self._unary_unary(
            "/nibiru.lockup.v1.Query/LockedCoins",
            request,
            QueryLockedCoinsResponse,
        )

    async def lock(self, *, id: int = 0) -> QueryLockResponse:
        request = QueryLockRequest()
        request.id = id

        return await self._unary_unary(
            "/nibiru.lockup.v1.Query/Lock",
            request,
            QueryLockResponse,
        )

    async def locks_by_address(
        self, *, address: str = "", pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryLocksByAddressResponse:
        request = QueryLocksByAddress()
        request.address = address
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nibiru.lockup.v1.Query/LocksByAddress",
            request,
            QueryLocksByAddressResponse,
        )
