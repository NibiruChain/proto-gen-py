# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: dex/v1/event.proto, dex/v1/genesis.proto, dex/v1/params.proto, dex/v1/pool.proto, dex/v1/query.proto, dex/v1/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class PoolType(betterproto.Enum):
    """
    - `balancer`: Balancer are pools defined by the equation xy=k, extended by
    the weighs introduced by Balancer. - `stableswap`: Stableswap pools are
    defined by a combination of constant-product and constant-sum pool
    """

    BALANCER = 0
    STABLESWAP = 1


@dataclass(eq=False, repr=False)
class PoolParams(betterproto.Message):
    """Configuration parameters for the pool."""

    swap_fee: str = betterproto.string_field(1)
    exit_fee: str = betterproto.string_field(2)
    a: str = betterproto.string_field(3)
    """
    Amplification Parameter (A): Larger value of A make the curve better
    resemble a straight  line in the center (when pool is near balance).
    Highly volatile assets should use a lower value, while assets that  are
    closer together may be best with a higher value. This is only used if the
    pool_type is set to 1 (stableswap)
    """

    pool_type: "PoolType" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class PoolAsset(betterproto.Message):
    """Which assets the pool contains."""

    token: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    """
    Coins we are talking about, the denomination must be unique amongst all
    PoolAssets for this pool.
    """

    weight: str = betterproto.string_field(2)
    """Weight that is not normalized. This weight must be less than 2^50"""


@dataclass(eq=False, repr=False)
class Pool(betterproto.Message):
    id: int = betterproto.uint64_field(1)
    """The pool id."""

    address: str = betterproto.string_field(2)
    """The pool account address."""

    pool_params: "PoolParams" = betterproto.message_field(3)
    """Fees and other pool-specific parameters."""

    pool_assets: List["PoolAsset"] = betterproto.message_field(4)
    """
    These are assumed to be sorted by denomiation. They contain the pool asset
    and the information about the weight
    """

    total_weight: str = betterproto.string_field(5)
    """sum of all non-normalized pool weights"""

    total_shares: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(6)
    """sum of all LP tokens sent out"""


@dataclass(eq=False, repr=False)
class MsgCreatePool(betterproto.Message):
    creator: str = betterproto.string_field(1)
    pool_params: "PoolParams" = betterproto.message_field(2)
    pool_assets: List["PoolAsset"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgCreatePoolResponse(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class MsgJoinPool(betterproto.Message):
    """
    Message to join a pool (identified by poolId) with a set of tokens to
    deposit.
    """

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    tokens_in: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)
    use_all_coins: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class MsgJoinPoolResponse(betterproto.Message):
    """Response when a user joins a pool."""

    pool: "Pool" = betterproto.message_field(1)
    """the final state of the pool after a join"""

    num_pool_shares_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)
    """sum of LP tokens minted from the join"""

    remaining_coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(
        3
    )
    """remaining tokens from attempting to join the pool"""


@dataclass(eq=False, repr=False)
class MsgExitPool(betterproto.Message):
    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    pool_shares: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgExitPoolResponse(betterproto.Message):
    tokens_out: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgSwapAssets(betterproto.Message):
    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    token_out_denom: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgSwapAssetsResponse(betterproto.Message):
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    starting_pool_number: int = betterproto.uint64_field(1)
    """
    The start pool number, i.e. the first pool number that isn't taken yet.
    """

    pool_creation_fee: List[
        "___cosmos_base_v1_beta1__.Coin"
    ] = betterproto.message_field(2)
    """The cost of creating a pool, taken from the pool creator's account."""

    whitelisted_asset: List[str] = betterproto.string_field(3)
    """The assets that can be used to create liquidity pools"""


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class QueryPoolNumberRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryPoolNumberResponse(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolResponse(betterproto.Message):
    pool: "Pool" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolsRequest(betterproto.Message):
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(1)
    )
    """pagination defines an optional pagination for the request."""


@dataclass(eq=False, repr=False)
class QueryPoolsResponse(betterproto.Message):
    pools: List["Pool"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )
    """pagination defines the pagination in the response."""


@dataclass(eq=False, repr=False)
class QueryPoolParamsRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryPoolParamsResponse(betterproto.Message):
    pool_params: "PoolParams" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryNumPoolsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryNumPoolsResponse(betterproto.Message):
    num_pools: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalLiquidityRequest(betterproto.Message):
    """
    -------------------------------------------- Query total liquidity the
    protocol
    """

    pass


@dataclass(eq=False, repr=False)
class QueryTotalLiquidityResponse(betterproto.Message):
    liquidity: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalPoolLiquidityRequest(betterproto.Message):
    """
    -------------------------------------------- Query total liquidity for a
    pool
    """

    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalPoolLiquidityResponse(betterproto.Message):
    liquidity: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalSharesRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryTotalSharesResponse(betterproto.Message):
    total_shares: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    """sum of all LP tokens sent out"""


@dataclass(eq=False, repr=False)
class QuerySpotPriceRequest(betterproto.Message):
    """
    Returns the amount of tokenInDenom to produce 1 tokenOutDenom For example,
    if the price of NIBI = 9.123 NUSD, then setting tokenInDenom=NUSD and
    tokenOutDenom=NIBI would give "9.123".
    """

    pool_id: int = betterproto.uint64_field(1)
    token_in_denom: str = betterproto.string_field(2)
    """the denomination of the token you are giving into the pool"""

    token_out_denom: str = betterproto.string_field(3)
    """the denomination of the token you are taking out of the pool"""


@dataclass(eq=False, repr=False)
class QuerySpotPriceResponse(betterproto.Message):
    spot_price: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountInRequest(betterproto.Message):
    """
    Given an exact amount of tokens in and a target tokenOutDenom, calculates
    the expected amount of tokens out received from a swap.
    """

    pool_id: int = betterproto.uint64_field(1)
    token_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)
    token_out_denom: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountInResponse(betterproto.Message):
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountOutRequest(betterproto.Message):
    """
    Given an exact amount of tokens out and a target tokenInDenom, calculates
    the expected amount of tokens in required to do the swap.
    """

    pool_id: int = betterproto.uint64_field(1)
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)
    token_in_denom: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class QuerySwapExactAmountOutResponse(betterproto.Message):
    token_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryJoinExactAmountInRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)
    tokens_in: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryJoinExactAmountInResponse(betterproto.Message):
    pool_shares_out: str = betterproto.string_field(1)
    """amount of pool shares returned to user after join"""

    rem_coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)
    """coins remaining after pool join"""


@dataclass(eq=False, repr=False)
class QueryJoinExactAmountOutRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryJoinExactAmountOutResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryExitExactAmountInRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)
    pool_shares_in: str = betterproto.string_field(2)
    """amount of pool shares to return to pool"""


@dataclass(eq=False, repr=False)
class QueryExitExactAmountInResponse(betterproto.Message):
    tokens_out: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(1)
    """coins obtained after exiting"""


@dataclass(eq=False, repr=False)
class QueryExitExactAmountOutRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryExitExactAmountOutResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class EventPoolJoined(betterproto.Message):
    address: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    tokens_in: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)
    pool_shares_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(4)
    rem_coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class EventPoolCreated(betterproto.Message):
    creator: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class EventPoolExited(betterproto.Message):
    address: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    pool_shares_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    tokens_out: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class EventAssetsSwapped(betterproto.Message):
    address: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    token_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the dex module's genesis state."""

    params: "Params" = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    async def create_pool(
        self,
        msg_create_pool: "MsgCreatePool",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCreatePoolResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Msg/CreatePool",
            msg_create_pool,
            MsgCreatePoolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def join_pool(
        self,
        msg_join_pool: "MsgJoinPool",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgJoinPoolResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Msg/JoinPool",
            msg_join_pool,
            MsgJoinPoolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def exit_pool(
        self,
        msg_exit_pool: "MsgExitPool",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgExitPoolResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Msg/ExitPool",
            msg_exit_pool,
            MsgExitPoolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def swap_assets(
        self,
        msg_swap_assets: "MsgSwapAssets",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgSwapAssetsResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Msg/SwapAssets",
            msg_swap_assets,
            MsgSwapAssetsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def pool_number(
        self,
        query_pool_number_request: "QueryPoolNumberRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPoolNumberResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/PoolNumber",
            query_pool_number_request,
            QueryPoolNumberResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def pool(
        self,
        query_pool_request: "QueryPoolRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPoolResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/Pool",
            query_pool_request,
            QueryPoolResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def pools(
        self,
        query_pools_request: "QueryPoolsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPoolsResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/Pools",
            query_pools_request,
            QueryPoolsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def pool_params(
        self,
        query_pool_params_request: "QueryPoolParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPoolParamsResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/PoolParams",
            query_pool_params_request,
            QueryPoolParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def num_pools(
        self,
        query_num_pools_request: "QueryNumPoolsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryNumPoolsResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/NumPools",
            query_num_pools_request,
            QueryNumPoolsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def total_liquidity(
        self,
        query_total_liquidity_request: "QueryTotalLiquidityRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryTotalLiquidityResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/TotalLiquidity",
            query_total_liquidity_request,
            QueryTotalLiquidityResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def total_pool_liquidity(
        self,
        query_total_pool_liquidity_request: "QueryTotalPoolLiquidityRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryTotalPoolLiquidityResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/TotalPoolLiquidity",
            query_total_pool_liquidity_request,
            QueryTotalPoolLiquidityResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def total_shares(
        self,
        query_total_shares_request: "QueryTotalSharesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryTotalSharesResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/TotalShares",
            query_total_shares_request,
            QueryTotalSharesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def spot_price(
        self,
        query_spot_price_request: "QuerySpotPriceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QuerySpotPriceResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/SpotPrice",
            query_spot_price_request,
            QuerySpotPriceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def estimate_swap_exact_amount_in(
        self,
        query_swap_exact_amount_in_request: "QuerySwapExactAmountInRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QuerySwapExactAmountInResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateSwapExactAmountIn",
            query_swap_exact_amount_in_request,
            QuerySwapExactAmountInResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def estimate_swap_exact_amount_out(
        self,
        query_swap_exact_amount_out_request: "QuerySwapExactAmountOutRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QuerySwapExactAmountOutResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateSwapExactAmountOut",
            query_swap_exact_amount_out_request,
            QuerySwapExactAmountOutResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def estimate_join_exact_amount_in(
        self,
        query_join_exact_amount_in_request: "QueryJoinExactAmountInRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryJoinExactAmountInResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateJoinExactAmountIn",
            query_join_exact_amount_in_request,
            QueryJoinExactAmountInResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def estimate_join_exact_amount_out(
        self,
        query_join_exact_amount_out_request: "QueryJoinExactAmountOutRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryJoinExactAmountOutResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateJoinExactAmountOut",
            query_join_exact_amount_out_request,
            QueryJoinExactAmountOutResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def estimate_exit_exact_amount_in(
        self,
        query_exit_exact_amount_in_request: "QueryExitExactAmountInRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryExitExactAmountInResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateExitExactAmountIn",
            query_exit_exact_amount_in_request,
            QueryExitExactAmountInResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def estimate_exit_exact_amount_out(
        self,
        query_exit_exact_amount_out_request: "QueryExitExactAmountOutRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryExitExactAmountOutResponse":
        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateExitExactAmountOut",
            query_exit_exact_amount_out_request,
            QueryExitExactAmountOutResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def create_pool(
        self, msg_create_pool: "MsgCreatePool"
    ) -> "MsgCreatePoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def join_pool(self, msg_join_pool: "MsgJoinPool") -> "MsgJoinPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def exit_pool(self, msg_exit_pool: "MsgExitPool") -> "MsgExitPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def swap_assets(
        self, msg_swap_assets: "MsgSwapAssets"
    ) -> "MsgSwapAssetsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_pool(
        self, stream: "grpclib.server.Stream[MsgCreatePool, MsgCreatePoolResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_pool(request)
        await stream.send_message(response)

    async def __rpc_join_pool(
        self, stream: "grpclib.server.Stream[MsgJoinPool, MsgJoinPoolResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.join_pool(request)
        await stream.send_message(response)

    async def __rpc_exit_pool(
        self, stream: "grpclib.server.Stream[MsgExitPool, MsgExitPoolResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.exit_pool(request)
        await stream.send_message(response)

    async def __rpc_swap_assets(
        self, stream: "grpclib.server.Stream[MsgSwapAssets, MsgSwapAssetsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.swap_assets(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.dex.v1.Msg/CreatePool": grpclib.const.Handler(
                self.__rpc_create_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreatePool,
                MsgCreatePoolResponse,
            ),
            "/nibiru.dex.v1.Msg/JoinPool": grpclib.const.Handler(
                self.__rpc_join_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgJoinPool,
                MsgJoinPoolResponse,
            ),
            "/nibiru.dex.v1.Msg/ExitPool": grpclib.const.Handler(
                self.__rpc_exit_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgExitPool,
                MsgExitPoolResponse,
            ),
            "/nibiru.dex.v1.Msg/SwapAssets": grpclib.const.Handler(
                self.__rpc_swap_assets,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSwapAssets,
                MsgSwapAssetsResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool_number(
        self, query_pool_number_request: "QueryPoolNumberRequest"
    ) -> "QueryPoolNumberResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool(self, query_pool_request: "QueryPoolRequest") -> "QueryPoolResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pools(
        self, query_pools_request: "QueryPoolsRequest"
    ) -> "QueryPoolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pool_params(
        self, query_pool_params_request: "QueryPoolParamsRequest"
    ) -> "QueryPoolParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def num_pools(
        self, query_num_pools_request: "QueryNumPoolsRequest"
    ) -> "QueryNumPoolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_liquidity(
        self, query_total_liquidity_request: "QueryTotalLiquidityRequest"
    ) -> "QueryTotalLiquidityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_pool_liquidity(
        self, query_total_pool_liquidity_request: "QueryTotalPoolLiquidityRequest"
    ) -> "QueryTotalPoolLiquidityResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def total_shares(
        self, query_total_shares_request: "QueryTotalSharesRequest"
    ) -> "QueryTotalSharesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def spot_price(
        self, query_spot_price_request: "QuerySpotPriceRequest"
    ) -> "QuerySpotPriceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_swap_exact_amount_in(
        self, query_swap_exact_amount_in_request: "QuerySwapExactAmountInRequest"
    ) -> "QuerySwapExactAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_swap_exact_amount_out(
        self, query_swap_exact_amount_out_request: "QuerySwapExactAmountOutRequest"
    ) -> "QuerySwapExactAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_join_exact_amount_in(
        self, query_join_exact_amount_in_request: "QueryJoinExactAmountInRequest"
    ) -> "QueryJoinExactAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_join_exact_amount_out(
        self, query_join_exact_amount_out_request: "QueryJoinExactAmountOutRequest"
    ) -> "QueryJoinExactAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_exit_exact_amount_in(
        self, query_exit_exact_amount_in_request: "QueryExitExactAmountInRequest"
    ) -> "QueryExitExactAmountInResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def estimate_exit_exact_amount_out(
        self, query_exit_exact_amount_out_request: "QueryExitExactAmountOutRequest"
    ) -> "QueryExitExactAmountOutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    async def __rpc_pool_number(
        self,
        stream: "grpclib.server.Stream[QueryPoolNumberRequest, QueryPoolNumberResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.pool_number(request)
        await stream.send_message(response)

    async def __rpc_pool(
        self, stream: "grpclib.server.Stream[QueryPoolRequest, QueryPoolResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.pool(request)
        await stream.send_message(response)

    async def __rpc_pools(
        self, stream: "grpclib.server.Stream[QueryPoolsRequest, QueryPoolsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.pools(request)
        await stream.send_message(response)

    async def __rpc_pool_params(
        self,
        stream: "grpclib.server.Stream[QueryPoolParamsRequest, QueryPoolParamsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.pool_params(request)
        await stream.send_message(response)

    async def __rpc_num_pools(
        self,
        stream: "grpclib.server.Stream[QueryNumPoolsRequest, QueryNumPoolsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.num_pools(request)
        await stream.send_message(response)

    async def __rpc_total_liquidity(
        self,
        stream: "grpclib.server.Stream[QueryTotalLiquidityRequest, QueryTotalLiquidityResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.total_liquidity(request)
        await stream.send_message(response)

    async def __rpc_total_pool_liquidity(
        self,
        stream: "grpclib.server.Stream[QueryTotalPoolLiquidityRequest, QueryTotalPoolLiquidityResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.total_pool_liquidity(request)
        await stream.send_message(response)

    async def __rpc_total_shares(
        self,
        stream: "grpclib.server.Stream[QueryTotalSharesRequest, QueryTotalSharesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.total_shares(request)
        await stream.send_message(response)

    async def __rpc_spot_price(
        self,
        stream: "grpclib.server.Stream[QuerySpotPriceRequest, QuerySpotPriceResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.spot_price(request)
        await stream.send_message(response)

    async def __rpc_estimate_swap_exact_amount_in(
        self,
        stream: "grpclib.server.Stream[QuerySwapExactAmountInRequest, QuerySwapExactAmountInResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.estimate_swap_exact_amount_in(request)
        await stream.send_message(response)

    async def __rpc_estimate_swap_exact_amount_out(
        self,
        stream: "grpclib.server.Stream[QuerySwapExactAmountOutRequest, QuerySwapExactAmountOutResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.estimate_swap_exact_amount_out(request)
        await stream.send_message(response)

    async def __rpc_estimate_join_exact_amount_in(
        self,
        stream: "grpclib.server.Stream[QueryJoinExactAmountInRequest, QueryJoinExactAmountInResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.estimate_join_exact_amount_in(request)
        await stream.send_message(response)

    async def __rpc_estimate_join_exact_amount_out(
        self,
        stream: "grpclib.server.Stream[QueryJoinExactAmountOutRequest, QueryJoinExactAmountOutResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.estimate_join_exact_amount_out(request)
        await stream.send_message(response)

    async def __rpc_estimate_exit_exact_amount_in(
        self,
        stream: "grpclib.server.Stream[QueryExitExactAmountInRequest, QueryExitExactAmountInResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.estimate_exit_exact_amount_in(request)
        await stream.send_message(response)

    async def __rpc_estimate_exit_exact_amount_out(
        self,
        stream: "grpclib.server.Stream[QueryExitExactAmountOutRequest, QueryExitExactAmountOutResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.estimate_exit_exact_amount_out(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.dex.v1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
            "/nibiru.dex.v1.Query/PoolNumber": grpclib.const.Handler(
                self.__rpc_pool_number,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolNumberRequest,
                QueryPoolNumberResponse,
            ),
            "/nibiru.dex.v1.Query/Pool": grpclib.const.Handler(
                self.__rpc_pool,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolRequest,
                QueryPoolResponse,
            ),
            "/nibiru.dex.v1.Query/Pools": grpclib.const.Handler(
                self.__rpc_pools,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolsRequest,
                QueryPoolsResponse,
            ),
            "/nibiru.dex.v1.Query/PoolParams": grpclib.const.Handler(
                self.__rpc_pool_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPoolParamsRequest,
                QueryPoolParamsResponse,
            ),
            "/nibiru.dex.v1.Query/NumPools": grpclib.const.Handler(
                self.__rpc_num_pools,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNumPoolsRequest,
                QueryNumPoolsResponse,
            ),
            "/nibiru.dex.v1.Query/TotalLiquidity": grpclib.const.Handler(
                self.__rpc_total_liquidity,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalLiquidityRequest,
                QueryTotalLiquidityResponse,
            ),
            "/nibiru.dex.v1.Query/TotalPoolLiquidity": grpclib.const.Handler(
                self.__rpc_total_pool_liquidity,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalPoolLiquidityRequest,
                QueryTotalPoolLiquidityResponse,
            ),
            "/nibiru.dex.v1.Query/TotalShares": grpclib.const.Handler(
                self.__rpc_total_shares,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryTotalSharesRequest,
                QueryTotalSharesResponse,
            ),
            "/nibiru.dex.v1.Query/SpotPrice": grpclib.const.Handler(
                self.__rpc_spot_price,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySpotPriceRequest,
                QuerySpotPriceResponse,
            ),
            "/nibiru.dex.v1.Query/EstimateSwapExactAmountIn": grpclib.const.Handler(
                self.__rpc_estimate_swap_exact_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySwapExactAmountInRequest,
                QuerySwapExactAmountInResponse,
            ),
            "/nibiru.dex.v1.Query/EstimateSwapExactAmountOut": grpclib.const.Handler(
                self.__rpc_estimate_swap_exact_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                QuerySwapExactAmountOutRequest,
                QuerySwapExactAmountOutResponse,
            ),
            "/nibiru.dex.v1.Query/EstimateJoinExactAmountIn": grpclib.const.Handler(
                self.__rpc_estimate_join_exact_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryJoinExactAmountInRequest,
                QueryJoinExactAmountInResponse,
            ),
            "/nibiru.dex.v1.Query/EstimateJoinExactAmountOut": grpclib.const.Handler(
                self.__rpc_estimate_join_exact_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryJoinExactAmountOutRequest,
                QueryJoinExactAmountOutResponse,
            ),
            "/nibiru.dex.v1.Query/EstimateExitExactAmountIn": grpclib.const.Handler(
                self.__rpc_estimate_exit_exact_amount_in,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryExitExactAmountInRequest,
                QueryExitExactAmountInResponse,
            ),
            "/nibiru.dex.v1.Query/EstimateExitExactAmountOut": grpclib.const.Handler(
                self.__rpc_estimate_exit_exact_amount_out,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryExitExactAmountOutRequest,
                QueryExitExactAmountOutResponse,
            ),
        }
