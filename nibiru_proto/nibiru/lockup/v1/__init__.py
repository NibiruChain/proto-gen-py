# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: lockup/v1/genesis.proto, lockup/v1/lock.proto, lockup/v1/query.proto, lockup/v1/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ....cosmos.base.query import v1beta1 as ___cosmos_base_query_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class Lock(betterproto.Message):
    """
    Lock represents a users locked tokens for a period of time. It stores
    owner, duration, unlock time and the amount of coins locked.
    """

    lock_id: int = betterproto.uint64_field(1)
    """unique autoincrementing numeric lock id"""

    owner: str = betterproto.string_field(2)
    """the user's address who owns the tokens that are locked"""

    duration: timedelta = betterproto.message_field(3)
    """the duration that the lock is locked for"""

    end_time: datetime = betterproto.message_field(4)
    """when the lock was unlocked"""

    coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(5)
    """the coins locked in this Lock"""


@dataclass(eq=False, repr=False)
class MsgLockTokens(betterproto.Message):
    owner: str = betterproto.string_field(1)
    duration: timedelta = betterproto.message_field(2)
    coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgLockTokensResponse(betterproto.Message):
    lock_id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class MsgInitiateUnlock(betterproto.Message):
    owner: str = betterproto.string_field(1)
    lock_id: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class MsgInitiateUnlockResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgUnlock(betterproto.Message):
    owner: str = betterproto.string_field(1)
    lock_id: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class MsgUnlockResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class EventLock(betterproto.Message):
    lock_id: int = betterproto.uint64_field(1)
    owner: str = betterproto.string_field(2)
    duration: timedelta = betterproto.message_field(3)
    coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class EventUnlockInitiated(betterproto.Message):
    lock_id: int = betterproto.uint64_field(1)
    owner: str = betterproto.string_field(2)
    coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)
    unlocking_at: datetime = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class EventUnlock(betterproto.Message):
    lock_id: int = betterproto.uint64_field(1)
    owner: str = betterproto.string_field(2)
    coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class QueryLockedCoinsRequest(betterproto.Message):
    address: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryLockedCoinsResponse(betterproto.Message):
    locked_coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class QueryLockRequest(betterproto.Message):
    id: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class QueryLockResponse(betterproto.Message):
    lock: "Lock" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryLocksByAddress(betterproto.Message):
    address: str = betterproto.string_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageRequest" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class QueryLocksByAddressResponse(betterproto.Message):
    locks: List["Lock"] = betterproto.message_field(1)
    pagination: "___cosmos_base_query_v1_beta1__.PageResponse" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the lockup module's genesis state."""

    locks: List["Lock"] = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    async def lock_tokens(
        self,
        msg_lock_tokens: "MsgLockTokens",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgLockTokensResponse":
        return await self._unary_unary(
            "/nibiru.lockup.v1.Msg/LockTokens",
            msg_lock_tokens,
            MsgLockTokensResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def initiate_unlock(
        self,
        msg_initiate_unlock: "MsgInitiateUnlock",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgInitiateUnlockResponse":
        return await self._unary_unary(
            "/nibiru.lockup.v1.Msg/InitiateUnlock",
            msg_initiate_unlock,
            MsgInitiateUnlockResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def unlock(
        self,
        msg_unlock: "MsgUnlock",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUnlockResponse":
        return await self._unary_unary(
            "/nibiru.lockup.v1.Msg/Unlock",
            msg_unlock,
            MsgUnlockResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def locked_coins(
        self,
        query_locked_coins_request: "QueryLockedCoinsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryLockedCoinsResponse":
        return await self._unary_unary(
            "/nibiru.lockup.v1.Query/LockedCoins",
            query_locked_coins_request,
            QueryLockedCoinsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def lock(
        self,
        query_lock_request: "QueryLockRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryLockResponse":
        return await self._unary_unary(
            "/nibiru.lockup.v1.Query/Lock",
            query_lock_request,
            QueryLockResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def locks_by_address(
        self,
        query_locks_by_address: "QueryLocksByAddress",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryLocksByAddressResponse":
        return await self._unary_unary(
            "/nibiru.lockup.v1.Query/LocksByAddress",
            query_locks_by_address,
            QueryLocksByAddressResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def lock_tokens(
        self, msg_lock_tokens: "MsgLockTokens"
    ) -> "MsgLockTokensResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def initiate_unlock(
        self, msg_initiate_unlock: "MsgInitiateUnlock"
    ) -> "MsgInitiateUnlockResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def unlock(self, msg_unlock: "MsgUnlock") -> "MsgUnlockResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_lock_tokens(
        self, stream: "grpclib.server.Stream[MsgLockTokens, MsgLockTokensResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.lock_tokens(request)
        await stream.send_message(response)

    async def __rpc_initiate_unlock(
        self,
        stream: "grpclib.server.Stream[MsgInitiateUnlock, MsgInitiateUnlockResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.initiate_unlock(request)
        await stream.send_message(response)

    async def __rpc_unlock(
        self, stream: "grpclib.server.Stream[MsgUnlock, MsgUnlockResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.unlock(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.lockup.v1.Msg/LockTokens": grpclib.const.Handler(
                self.__rpc_lock_tokens,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgLockTokens,
                MsgLockTokensResponse,
            ),
            "/nibiru.lockup.v1.Msg/InitiateUnlock": grpclib.const.Handler(
                self.__rpc_initiate_unlock,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgInitiateUnlock,
                MsgInitiateUnlockResponse,
            ),
            "/nibiru.lockup.v1.Msg/Unlock": grpclib.const.Handler(
                self.__rpc_unlock,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUnlock,
                MsgUnlockResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def locked_coins(
        self, query_locked_coins_request: "QueryLockedCoinsRequest"
    ) -> "QueryLockedCoinsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def lock(self, query_lock_request: "QueryLockRequest") -> "QueryLockResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def locks_by_address(
        self, query_locks_by_address: "QueryLocksByAddress"
    ) -> "QueryLocksByAddressResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_locked_coins(
        self,
        stream: "grpclib.server.Stream[QueryLockedCoinsRequest, QueryLockedCoinsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.locked_coins(request)
        await stream.send_message(response)

    async def __rpc_lock(
        self, stream: "grpclib.server.Stream[QueryLockRequest, QueryLockResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.lock(request)
        await stream.send_message(response)

    async def __rpc_locks_by_address(
        self,
        stream: "grpclib.server.Stream[QueryLocksByAddress, QueryLocksByAddressResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.locks_by_address(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.lockup.v1.Query/LockedCoins": grpclib.const.Handler(
                self.__rpc_locked_coins,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLockedCoinsRequest,
                QueryLockedCoinsResponse,
            ),
            "/nibiru.lockup.v1.Query/Lock": grpclib.const.Handler(
                self.__rpc_lock,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLockRequest,
                QueryLockResponse,
            ),
            "/nibiru.lockup.v1.Query/LocksByAddress": grpclib.const.Handler(
                self.__rpc_locks_by_address,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLocksByAddress,
                QueryLocksByAddressResponse,
            ),
        }
