# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: vpool/v1/event.proto, vpool/v1/genesis.proto, vpool/v1/gov.proto, vpool/v1/query.proto, vpool/v1/state.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ... import common as __common__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class Direction(betterproto.Enum):
    DIRECTION_UNSPECIFIED = 0
    ADD_TO_POOL = 1
    REMOVE_FROM_POOL = 2


class TwapCalcOption(betterproto.Enum):
    """Enumerates different options of calculating twap."""

    TWAP_CALC_OPTION_UNSPECIFIED = 0
    SPOT = 1
    """Spot price from quote asset reserve / base asset reserve"""

    QUOTE_ASSET_SWAP = 2
    """Swapping with quote assets, output denominated in base assets"""

    BASE_ASSET_SWAP = 3
    """Swapping with base assets, output denominated in quote assets"""


@dataclass(eq=False, repr=False)
class Vpool(betterproto.Message):
    """
    A virtual pool used only for price discovery of perpetual futures
    contracts. No real liquidity exists in this pool.
    """

    pair: "__common__.AssetPair" = betterproto.message_field(1)
    """always BASE:QUOTE, e.g. BTC:NUSD or ETH:NUSD"""

    base_asset_reserve: str = betterproto.string_field(2)
    """base asset is the crypto asset, e.g. BTC or ETH"""

    quote_asset_reserve: str = betterproto.string_field(3)
    """quote asset is usually stablecoin, in our case NUSD"""

    config: "VpoolConfig" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class VpoolConfig(betterproto.Message):
    trade_limit_ratio: str = betterproto.string_field(1)
    """ratio applied to reserves in order not to over trade"""

    fluctuation_limit_ratio: str = betterproto.string_field(2)
    """
    percentage that a single open or close position can alter the reserve
    amounts
    """

    max_oracle_spread_ratio: str = betterproto.string_field(3)
    """max_oracle_spread_ratio"""

    maintenance_margin_ratio: str = betterproto.string_field(4)
    """maintenance_margin_ratio"""

    max_leverage: str = betterproto.string_field(5)
    """max_leverage"""


@dataclass(eq=False, repr=False)
class CurrentTwap(betterproto.Message):
    """
    CurrentTWAP states defines the numerator and denominator for the TWAP
    calculation
    """

    pair_id: str = betterproto.string_field(1)
    numerator: str = betterproto.string_field(2)
    denominator: str = betterproto.string_field(3)
    price: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class ReserveSnapshot(betterproto.Message):
    """a snapshot of the vpool's reserves at a given point in time"""

    pair: "__common__.AssetPair" = betterproto.message_field(5)
    base_asset_reserve: str = betterproto.string_field(1)
    quote_asset_reserve: str = betterproto.string_field(2)
    """quote asset is usually the margin asset, e.g. NUSD"""

    timestamp_ms: int = betterproto.int64_field(3)
    """milliseconds since unix epoch"""


@dataclass(eq=False, repr=False)
class PoolPrices(betterproto.Message):
    """
    PoolPrices is a simple structure that displays a snapshot of the mark and
    index prices for an asset. Empty strings for the indexPrice or twapMark
    fields  indicate that the price is currently unavailable.
    """

    pair: str = betterproto.string_field(9)
    """Pair identifier for the two assets. Always in format 'base:quote'"""

    mark_price: str = betterproto.string_field(10)
    """
    MarkPrice is the instantaneous price of the perp.  Equivalent to
    quoteAssetReserve / baseAssetReserve.
    """

    index_price: str = betterproto.string_field(11)
    """IndexPrice is the price of the "underlying" for the perp"""

    twap_mark: str = betterproto.string_field(12)
    """TwapMark is the time-weighted average (mark) price."""

    swap_invariant: str = betterproto.string_field(13)
    """
    SwapInvariant is the product of the reserves, commonly referred to as "k".
    """

    block_number: int = betterproto.int64_field(14)
    """The block number corresponding to each price"""


@dataclass(eq=False, repr=False)
class CreatePoolProposal(betterproto.Message):
    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    pair: str = betterproto.string_field(3)
    """pair represents the pair of the vpool."""

    quote_asset_reserve: str = betterproto.string_field(5)
    """
    quote_asset_reserve is the amount of quote asset the pool will be
    initialized with.
    """

    base_asset_reserve: str = betterproto.string_field(6)
    """
    base_asset_reserve is the amount of base asset the pool will be initialized
    with.
    """

    config: "VpoolConfig" = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class EditPoolConfigProposal(betterproto.Message):
    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    pair: str = betterproto.string_field(3)
    config: "VpoolConfig" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class EditSwapInvariantsProposal(betterproto.Message):
    """
    EditSwapInvariantsProposal is a governance proposal to change the swap
    invariant of the virtual pool for one or more trading pairs.
    """

    title: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    swap_invariant_maps: List[
        "EditSwapInvariantsProposalSwapInvariantMultiple"
    ] = betterproto.message_field(5)
    """
    Map from pair ID to a multiple on the swap invariant. For example, a
    proposal containing  "swap_invariant_maps": [{ "uatom:unusd": "5" }, {
    "uosmo:unusd": "0.9" }] would mutliply the swap invariant of the ATOM and
    OSMO trading pairs by  5 and 0.9 respectively. The price at which k changes
    is the instantaneous  mark price at the time of the proposal's execution.
    """


@dataclass(eq=False, repr=False)
class EditSwapInvariantsProposalSwapInvariantMultiple(betterproto.Message):
    """
    A map between a trading pair and a desired multiplier for its swap
    invariant.
    """

    pair: str = betterproto.string_field(3)
    """Pair is a string identifier for an asset pair."""

    multiplier: str = betterproto.string_field(4)
    """
    Multiplier is a number representing the desired percentage change to the
    swap invariant of the AMM pool underlying 'pair'
    """


@dataclass(eq=False, repr=False)
class QueryReserveAssetsRequest(betterproto.Message):
    pair: str = betterproto.string_field(1)
    """always BASE:QUOTE, e.g. BTC:NUSD or ETH:NUSD"""


@dataclass(eq=False, repr=False)
class QueryReserveAssetsResponse(betterproto.Message):
    base_asset_reserve: str = betterproto.string_field(1)
    """base asset is the crypto asset, e.g. BTC or ETH"""

    quote_asset_reserve: str = betterproto.string_field(2)
    """quote asset is usually stablecoin, in our case NUSD"""


@dataclass(eq=False, repr=False)
class QueryAllPoolsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryAllPoolsResponse(betterproto.Message):
    pools: List["Vpool"] = betterproto.message_field(1)
    prices: List["PoolPrices"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryBaseAssetPriceRequest(betterproto.Message):
    pair: str = betterproto.string_field(1)
    direction: "Direction" = betterproto.enum_field(2)
    base_asset_amount: str = betterproto.string_field(3)
    """base asset is the crypto asset, e.g. BTC or ETH"""


@dataclass(eq=False, repr=False)
class QueryBaseAssetPriceResponse(betterproto.Message):
    price_in_quote_denom: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ReserveSnapshotSavedEvent(betterproto.Message):
    pair: str = betterproto.string_field(1)
    quote_reserve: str = betterproto.string_field(2)
    base_reserve: str = betterproto.string_field(3)
    mark_price: str = betterproto.string_field(4)
    """
    MarkPrice at the end of the block.  (instantaneous) markPrice :=
    quoteReserve / baseReserve
    """

    block_height: int = betterproto.int64_field(5)
    block_timestamp: datetime = betterproto.message_field(6)


@dataclass(eq=False, repr=False)
class SwapOnVpoolEvent(betterproto.Message):
    """
    A swap on the vpool represented by 'pair'.  Amounts are negative or
    positive base on the perspective of the pool, i.e. a negative quote means
    the trader has gained quote and the vpool lost quote.
    """

    pair: str = betterproto.string_field(1)
    quote_amount: str = betterproto.string_field(2)
    """delta in the quote reserves of the vpool"""

    base_amount: str = betterproto.string_field(3)
    """delta in the base reserves of the vpool"""


@dataclass(eq=False, repr=False)
class MarkPriceChangedEvent(betterproto.Message):
    pair: str = betterproto.string_field(1)
    price: str = betterproto.string_field(2)
    block_timestamp: datetime = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the vpool module's genesis state."""

    vpools: List["Vpool"] = betterproto.message_field(1)


class QueryStub(betterproto.ServiceStub):
    async def reserve_assets(
        self,
        query_reserve_assets_request: "QueryReserveAssetsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryReserveAssetsResponse":
        return await self._unary_unary(
            "/nibiru.vpool.v1.Query/ReserveAssets",
            query_reserve_assets_request,
            QueryReserveAssetsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def all_pools(
        self,
        query_all_pools_request: "QueryAllPoolsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryAllPoolsResponse":
        return await self._unary_unary(
            "/nibiru.vpool.v1.Query/AllPools",
            query_all_pools_request,
            QueryAllPoolsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def base_asset_price(
        self,
        query_base_asset_price_request: "QueryBaseAssetPriceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryBaseAssetPriceResponse":
        return await self._unary_unary(
            "/nibiru.vpool.v1.Query/BaseAssetPrice",
            query_base_asset_price_request,
            QueryBaseAssetPriceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def reserve_assets(
        self, query_reserve_assets_request: "QueryReserveAssetsRequest"
    ) -> "QueryReserveAssetsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def all_pools(
        self, query_all_pools_request: "QueryAllPoolsRequest"
    ) -> "QueryAllPoolsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def base_asset_price(
        self, query_base_asset_price_request: "QueryBaseAssetPriceRequest"
    ) -> "QueryBaseAssetPriceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_reserve_assets(
        self,
        stream: "grpclib.server.Stream[QueryReserveAssetsRequest, QueryReserveAssetsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.reserve_assets(request)
        await stream.send_message(response)

    async def __rpc_all_pools(
        self,
        stream: "grpclib.server.Stream[QueryAllPoolsRequest, QueryAllPoolsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.all_pools(request)
        await stream.send_message(response)

    async def __rpc_base_asset_price(
        self,
        stream: "grpclib.server.Stream[QueryBaseAssetPriceRequest, QueryBaseAssetPriceResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.base_asset_price(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.vpool.v1.Query/ReserveAssets": grpclib.const.Handler(
                self.__rpc_reserve_assets,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryReserveAssetsRequest,
                QueryReserveAssetsResponse,
            ),
            "/nibiru.vpool.v1.Query/AllPools": grpclib.const.Handler(
                self.__rpc_all_pools,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryAllPoolsRequest,
                QueryAllPoolsResponse,
            ),
            "/nibiru.vpool.v1.Query/BaseAssetPrice": grpclib.const.Handler(
                self.__rpc_base_asset_price,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryBaseAssetPriceRequest,
                QueryBaseAssetPriceResponse,
            ),
        }
