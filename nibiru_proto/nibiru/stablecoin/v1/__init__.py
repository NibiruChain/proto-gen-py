# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: stablecoin/events.proto, stablecoin/genesis.proto, stablecoin/params.proto, stablecoin/query.proto, stablecoin/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class MsgMintStable(betterproto.Message):
    """
    MsgMintStable: Msg to mint NUSD. A user deposits NIBI and collateral and
    gets NUSD in return. The amount of NUSD received depends on the current
    price set by the oracle library and the current collateral ratio for the
    protocol.
    """

    creator: str = betterproto.string_field(1)
    stable: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class MsgMintStableResponse(betterproto.Message):
    """
    MsgMintStableResponse specifies the amount of NUSD token the user will
    receive after their mint transaction
    """

    stable: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    used_coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(2)
    fees_payed: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgBurnStable(betterproto.Message):
    """
    MsgBurnStable allows users to burn NUSD in exchange for NIBI and
    collateral. The amount of NIBI and Collateral received depends on the
    current price set by the x/oracle library and the current collateral ratio.
    """

    creator: str = betterproto.string_field(1)
    stable: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class MsgBurnStableResponse(betterproto.Message):
    """
    MsgBurnStableResponse specifies the amount of collateral and governance
    token the user will receive after their burn transaction.
    """

    collateral: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    gov: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)
    fees_payed: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgRecollateralize(betterproto.Message):
    """MsgRecollateralize"""

    creator: str = betterproto.string_field(1)
    coll: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class MsgRecollateralizeResponse(betterproto.Message):
    """
    MsgRecollateralizeResponse is the output of a successful 'Recollateralize'
    """

    gov: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    """
    Gov (sdk.Coin): Tokens rewarded to the caller in exchange for her
    collateral.
    """


@dataclass(eq=False, repr=False)
class MsgBuyback(betterproto.Message):
    """MsgBuyback"""

    creator: str = betterproto.string_field(1)
    gov: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)
    """
    Gov (sdk.Coin): Tokens the caller wants to sell to the protocol in exchange
    for collateral.
    """


@dataclass(eq=False, repr=False)
class MsgBuybackResponse(betterproto.Message):
    """MsgBuybackResponse is the output of a successful 'Buyback'"""

    coll: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    """
    Coll (sdk.Coin): Tokens sold to the caller in exchange for her collateral.
    """


@dataclass(eq=False, repr=False)
class EventTransfer(betterproto.Message):
    coin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    from_: str = betterproto.string_field(2)
    to: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class EventMintStable(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EventBurnStable(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EventMintNibi(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EventBurnNibi(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class EventRecollateralize(betterproto.Message):
    caller: str = betterproto.string_field(1)
    in_coin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)
    out_coin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    coll_ratio: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class EventBuyback(betterproto.Message):
    caller: str = betterproto.string_field(1)
    in_coin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)
    out_coin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    coll_ratio: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    coll_ratio: int = betterproto.int64_field(1)
    """collRatio is the ratio needed as collateral to exchange for stables"""

    fee_ratio: int = betterproto.int64_field(2)
    """feeRatio is the ratio taken as fees when minting or burning stables"""

    ef_fee_ratio: int = betterproto.int64_field(3)
    """
    efFeeRatio is the ratio taken from the fees that goes to Ecosystem Fund
    """

    bonus_rate_recoll: int = betterproto.int64_field(4)
    """
    BonusRateRecoll is the percentage of extra stablecoin value given to the
    callerof 'Recollateralize' in units of governance tokens.
    """

    distr_epoch_identifier: str = betterproto.string_field(5)
    """
    distr_epoch_identifier defines the frequnecy of update for the collateral
    ratio
    """

    adjustment_step: int = betterproto.int64_field(6)
    """
    adjustmentStep is the size of the step taken when updating the collateral
    ratio
    """

    price_lower_bound: int = betterproto.int64_field(7)
    """
    priceLowerBound is the lower bound for the stable coin to trigger a
    collateral ratio update
    """

    price_upper_bound: int = betterproto.int64_field(8)
    """
    priceUpperBound is the upper bound for the stable coin to trigger a
    collateral ratio update
    """

    is_collateral_ratio_valid: bool = betterproto.bool_field(9)
    """
    isCollateralRatioValid checks if the collateral ratio is correctly updated
    """


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class QueryModuleAccountBalances(betterproto.Message):
    """
    QueryModuleAccountBalances is the request type for the balance of the
    x/stablecoin module account.
    """

    pass


@dataclass(eq=False, repr=False)
class QueryModuleAccountBalancesResponse(betterproto.Message):
    module_account_balances: List[
        "___cosmos_base_v1_beta1__.Coin"
    ] = betterproto.message_field(1)
    """
    ModuleAccountBalances is the balance of all coins in the x/stablecoin
    module.
    """


@dataclass(eq=False, repr=False)
class QueryCirculatingSupplies(betterproto.Message):
    """
    QueryCirculatingSupplies is the request type for the circulating supply
    ofboth NIBI and NUSD.
    """

    pass


@dataclass(eq=False, repr=False)
class QueryCirculatingSuppliesResponse(betterproto.Message):
    nibi: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    nusd: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryGovToMintStable(betterproto.Message):
    """
    QueryGovToMintStable is the request type for the Query/GovToMintStable RPC
    method
    """

    collateral: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryGovToMintStableResponse(betterproto.Message):
    """
    QueryGovToMintStableResponse is the response type for
    'QueryGovToMintStable'
    """

    gov: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class LiquidityRatioInfo(betterproto.Message):
    liquidity_ratio: str = betterproto.string_field(1)
    upper_band: str = betterproto.string_field(2)
    lower_band: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class QueryLiquidityRatioInfoRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryLiquidityRatioInfoResponse(betterproto.Message):
    info: "LiquidityRatioInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the stablecoin module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    module_account_balance: "___cosmos_base_v1_beta1__.Coin" = (
        betterproto.message_field(2)
    )


class MsgStub(betterproto.ServiceStub):
    async def mint_stable(
        self,
        msg_mint_stable: "MsgMintStable",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgMintStableResponse":
        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Msg/MintStable",
            msg_mint_stable,
            MsgMintStableResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def burn_stable(
        self,
        msg_burn_stable: "MsgBurnStable",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgBurnStableResponse":
        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Msg/BurnStable",
            msg_burn_stable,
            MsgBurnStableResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def recollateralize(
        self,
        msg_recollateralize: "MsgRecollateralize",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgRecollateralizeResponse":
        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Msg/Recollateralize",
            msg_recollateralize,
            MsgRecollateralizeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def buyback(
        self,
        msg_buyback: "MsgBuyback",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgBuybackResponse":
        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Msg/Buyback",
            msg_buyback,
            MsgBuybackResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def module_account_balances(
        self,
        query_module_account_balances: "QueryModuleAccountBalances",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryModuleAccountBalancesResponse":
        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Query/ModuleAccountBalances",
            query_module_account_balances,
            QueryModuleAccountBalancesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def circulating_supplies(
        self,
        query_circulating_supplies: "QueryCirculatingSupplies",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryCirculatingSuppliesResponse":
        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Query/CirculatingSupplies",
            query_circulating_supplies,
            QueryCirculatingSuppliesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def liquidity_ratio_info(
        self,
        query_liquidity_ratio_info_request: "QueryLiquidityRatioInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryLiquidityRatioInfoResponse":
        return await self._unary_unary(
            "/nibiru.stablecoin.v1.Query/LiquidityRatioInfo",
            query_liquidity_ratio_info_request,
            QueryLiquidityRatioInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def mint_stable(
        self, msg_mint_stable: "MsgMintStable"
    ) -> "MsgMintStableResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def burn_stable(
        self, msg_burn_stable: "MsgBurnStable"
    ) -> "MsgBurnStableResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def recollateralize(
        self, msg_recollateralize: "MsgRecollateralize"
    ) -> "MsgRecollateralizeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def buyback(self, msg_buyback: "MsgBuyback") -> "MsgBuybackResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_mint_stable(
        self, stream: "grpclib.server.Stream[MsgMintStable, MsgMintStableResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.mint_stable(request)
        await stream.send_message(response)

    async def __rpc_burn_stable(
        self, stream: "grpclib.server.Stream[MsgBurnStable, MsgBurnStableResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.burn_stable(request)
        await stream.send_message(response)

    async def __rpc_recollateralize(
        self,
        stream: "grpclib.server.Stream[MsgRecollateralize, MsgRecollateralizeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.recollateralize(request)
        await stream.send_message(response)

    async def __rpc_buyback(
        self, stream: "grpclib.server.Stream[MsgBuyback, MsgBuybackResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.buyback(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.stablecoin.v1.Msg/MintStable": grpclib.const.Handler(
                self.__rpc_mint_stable,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgMintStable,
                MsgMintStableResponse,
            ),
            "/nibiru.stablecoin.v1.Msg/BurnStable": grpclib.const.Handler(
                self.__rpc_burn_stable,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgBurnStable,
                MsgBurnStableResponse,
            ),
            "/nibiru.stablecoin.v1.Msg/Recollateralize": grpclib.const.Handler(
                self.__rpc_recollateralize,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgRecollateralize,
                MsgRecollateralizeResponse,
            ),
            "/nibiru.stablecoin.v1.Msg/Buyback": grpclib.const.Handler(
                self.__rpc_buyback,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgBuyback,
                MsgBuybackResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def module_account_balances(
        self, query_module_account_balances: "QueryModuleAccountBalances"
    ) -> "QueryModuleAccountBalancesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def circulating_supplies(
        self, query_circulating_supplies: "QueryCirculatingSupplies"
    ) -> "QueryCirculatingSuppliesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def liquidity_ratio_info(
        self, query_liquidity_ratio_info_request: "QueryLiquidityRatioInfoRequest"
    ) -> "QueryLiquidityRatioInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    async def __rpc_module_account_balances(
        self,
        stream: "grpclib.server.Stream[QueryModuleAccountBalances, QueryModuleAccountBalancesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.module_account_balances(request)
        await stream.send_message(response)

    async def __rpc_circulating_supplies(
        self,
        stream: "grpclib.server.Stream[QueryCirculatingSupplies, QueryCirculatingSuppliesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.circulating_supplies(request)
        await stream.send_message(response)

    async def __rpc_liquidity_ratio_info(
        self,
        stream: "grpclib.server.Stream[QueryLiquidityRatioInfoRequest, QueryLiquidityRatioInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.liquidity_ratio_info(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.stablecoin.v1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
            "/nibiru.stablecoin.v1.Query/ModuleAccountBalances": grpclib.const.Handler(
                self.__rpc_module_account_balances,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryModuleAccountBalances,
                QueryModuleAccountBalancesResponse,
            ),
            "/nibiru.stablecoin.v1.Query/CirculatingSupplies": grpclib.const.Handler(
                self.__rpc_circulating_supplies,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryCirculatingSupplies,
                QueryCirculatingSuppliesResponse,
            ),
            "/nibiru.stablecoin.v1.Query/LiquidityRatioInfo": grpclib.const.Handler(
                self.__rpc_liquidity_ratio_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLiquidityRatioInfoRequest,
                QueryLiquidityRatioInfoResponse,
            ),
        }
