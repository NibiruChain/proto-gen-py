# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: perp/v1/event.proto, perp/v1/genesis.proto, perp/v1/query.proto, perp/v1/state.proto, perp/v1/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import timedelta
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ....cosmos.base import v1beta1 as ___cosmos_base_v1_beta1__
from ... import common as __common__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class Side(betterproto.Enum):
    SIDE_UNSPECIFIED = 0
    BUY = 1
    SELL = 2


class PnLCalcOption(betterproto.Enum):
    PNL_CALC_OPTION_UNSPECIFIED = 0
    SPOT_PRICE = 1
    TWAP = 2
    ORACLE = 3


class PnLPreferenceOption(betterproto.Enum):
    PNL_PREFERENCE_UNSPECIFIED = 0
    MAX = 1
    MIN = 2


class MarginCalculationPriceOption(betterproto.Enum):
    MARGIN_CALCULATION_PRICE_OPTION_UNSPECIFIED = 0
    SPOT = 1
    INDEX = 2
    MAX_PNL = 3


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    stopped: bool = betterproto.bool_field(1)
    """stopped identifies if the perp exchange is stopped or not"""

    fee_pool_fee_ratio: str = betterproto.string_field(3)
    """FeePoolFeeRatio is the ratio transferred to the the fee pool"""

    ecosystem_fund_fee_ratio: str = betterproto.string_field(4)
    """EcosystemFundFeeRatio is the ratio transferred to the PerpEF."""

    liquidation_fee_ratio: str = betterproto.string_field(5)
    """
    LiquidationFeeRatio is the percentage of liquidated position that will be
    given to out as a reward. Half of the liquidation fee is given to the
    liquidator, and the other half is given to the ecosystem fund.
    """

    partial_liquidation_ratio: str = betterproto.string_field(6)
    """
    PartialLiquidationRatio is the share we try to liquidate if the margin is
    higher than liquidation fee
    """

    funding_rate_interval: str = betterproto.string_field(7)
    """specifies the interval on which the funding rate is updated"""

    twap_lookback_window: timedelta = betterproto.message_field(8)
    """amount of time to look back for TWAP calculations"""

    whitelisted_liquidators: List[str] = betterproto.string_field(9)
    """
    whitelisted_liquidators defines the list of addresses which are allowed to
    liquidate a position.
    """


@dataclass(eq=False, repr=False)
class Position(betterproto.Message):
    """
    Position identifies and records information on a user's position on one of
    the virtual liquidity pools.
    """

    trader_address: str = betterproto.string_field(1)
    """address identifies the address owner of this position"""

    pair: "__common__.AssetPair" = betterproto.message_field(2)
    """pair identifies the pair associated with this position"""

    size: str = betterproto.string_field(3)
    """Position size."""

    margin: str = betterproto.string_field(4)
    """Amount of margin remaining in the position."""

    open_notional: str = betterproto.string_field(5)
    """
    OpenNotional is the quote denom value of the position when opening. Used to
    calculate PnL.
    """

    latest_cumulative_premium_fraction: str = betterproto.string_field(6)
    """
    The most recent cumulative premium fraction this position has. Used to
    calculate the next funding payment.
    """

    block_number: int = betterproto.int64_field(7)
    """BlockNumber is the last block number when this position was updated."""


@dataclass(eq=False, repr=False)
class PairMetadata(betterproto.Message):
    pair: "__common__.AssetPair" = betterproto.message_field(1)
    latest_cumulative_premium_fraction: str = betterproto.string_field(2)
    """
    Latest cumulative premium fraction for a given pair. Calculated once per
    funding rate interval. A premium fraction is the difference between mark
    and index, divided by the number of payments per day. (mark - index) / #
    payments in a day
    """


@dataclass(eq=False, repr=False)
class PrepaidBadDebt(betterproto.Message):
    denom: str = betterproto.string_field(1)
    amount: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class PositionResp(betterproto.Message):
    position: "Position" = betterproto.message_field(1)
    exchanged_notional_value: str = betterproto.string_field(2)
    """The amount of quote assets exchanged."""

    exchanged_position_size: str = betterproto.string_field(3)
    """The amount of base assets exchanged."""

    bad_debt: str = betterproto.string_field(4)
    """
    The amount of bad debt accrued during this position change. Measured in
    absolute value of quote units. If greater than zero, then the position
    change event will likely fail.
    """

    funding_payment: str = betterproto.string_field(5)
    """The funding payment applied on this position change."""

    realized_pnl: str = betterproto.string_field(6)
    """
    The amount of PnL realized on this position changed, measured in quote
    units.
    """

    unrealized_pnl_after: str = betterproto.string_field(7)
    """The unrealized PnL in the position after the position change."""

    margin_to_vault: str = betterproto.string_field(8)
    """
    The amount of margin the trader has to give to the vault. A negative value
    means the vault pays the trader.
    """

    position_notional: str = betterproto.string_field(9)
    """
    The position's notional value after the position change, measured in quote
    units.
    """


@dataclass(eq=False, repr=False)
class LiquidateResp(betterproto.Message):
    bad_debt: str = betterproto.string_field(1)
    """Amount of bad debt created by the liquidation event"""

    fee_to_liquidator: str = betterproto.string_field(2)
    """Fee paid to the liquidator"""

    fee_to_perp_ecosystem_fund: str = betterproto.string_field(3)
    """Fee paid to the Perp EF fund"""

    liquidator: str = betterproto.string_field(4)
    """Address of the liquidator"""

    position_resp: "PositionResp" = betterproto.message_field(5)
    """Position response from the close or open reverse position"""


@dataclass(eq=False, repr=False)
class Metrics(betterproto.Message):
    """
    PoolMetrics is a structure that displays a snapshot of perp metrics for
    each pair.
    """

    pair: str = betterproto.string_field(1)
    """Pair identifier for the two assets. Always in format 'base:quote'"""

    net_size: str = betterproto.string_field(2)
    """Sum of all active position sizes for the pair."""

    volume_quote: str = betterproto.string_field(3)
    """Total notional volume for the pair."""

    volume_base: str = betterproto.string_field(4)
    """Total size volume for the pair."""


@dataclass(eq=False, repr=False)
class MsgRemoveMargin(betterproto.Message):
    """MsgRemoveMargin: Msg to remove margin."""

    sender: str = betterproto.string_field(1)
    token_pair: str = betterproto.string_field(2)
    margin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgRemoveMarginResponse(betterproto.Message):
    margin_out: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    """tokens transferred back to the trader"""

    funding_payment: str = betterproto.string_field(2)
    """the funding payment applied on this position interaction"""

    position: "Position" = betterproto.message_field(3)
    """The resulting position"""


@dataclass(eq=False, repr=False)
class MsgAddMargin(betterproto.Message):
    """MsgAddMargin: Msg to remove margin."""

    sender: str = betterproto.string_field(1)
    token_pair: str = betterproto.string_field(2)
    margin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MsgAddMarginResponse(betterproto.Message):
    funding_payment: str = betterproto.string_field(1)
    position: "Position" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class MsgLiquidate(betterproto.Message):
    sender: str = betterproto.string_field(1)
    """Sender is the liquidator address"""

    token_pair: str = betterproto.string_field(2)
    """TokenPair is the identifier for the position's virtual pool"""

    trader: str = betterproto.string_field(3)
    """Trader is the address of the owner of the position"""


@dataclass(eq=False, repr=False)
class MsgLiquidateResponse(betterproto.Message):
    fee_to_liquidator: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(1)
    fee_to_perp_ecosystem_fund: "___cosmos_base_v1_beta1__.Coin" = (
        betterproto.message_field(2)
    )


@dataclass(eq=False, repr=False)
class MsgMultiLiquidate(betterproto.Message):
    sender: str = betterproto.string_field(1)
    liquidations: List["MsgMultiLiquidateMultiLiquidation"] = betterproto.message_field(
        2
    )


@dataclass(eq=False, repr=False)
class MsgMultiLiquidateMultiLiquidation(betterproto.Message):
    token_pair: str = betterproto.string_field(2)
    trader: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MsgMultiLiquidateResponse(betterproto.Message):
    liquidation_responses: List[
        "MsgMultiLiquidateResponseMultiLiquidateResponse"
    ] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class MsgMultiLiquidateResponseMultiLiquidateResponse(betterproto.Message):
    error: str = betterproto.string_field(1, group="response")
    liquidation: "MsgLiquidateResponse" = betterproto.message_field(2, group="response")


@dataclass(eq=False, repr=False)
class MsgOpenPosition(betterproto.Message):
    sender: str = betterproto.string_field(1)
    token_pair: str = betterproto.string_field(2)
    side: "Side" = betterproto.enum_field(3)
    quote_asset_amount: str = betterproto.string_field(4)
    leverage: str = betterproto.string_field(5)
    base_asset_amount_limit: str = betterproto.string_field(6)


@dataclass(eq=False, repr=False)
class MsgOpenPositionResponse(betterproto.Message):
    position: "Position" = betterproto.message_field(1)
    exchanged_notional_value: str = betterproto.string_field(2)
    """The amount of quote assets exchanged."""

    exchanged_position_size: str = betterproto.string_field(3)
    """The amount of base assets exchanged."""

    funding_payment: str = betterproto.string_field(4)
    """
    The funding payment applied on this position change, measured in quote
    units.
    """

    realized_pnl: str = betterproto.string_field(5)
    """
    The amount of PnL realized on this position changed, measured in quote
    units.
    """

    unrealized_pnl_after: str = betterproto.string_field(6)
    """
    The unrealized PnL in the position after the position change, measured in
    quote units.
    """

    margin_to_vault: str = betterproto.string_field(7)
    """
    The amount of margin the trader has to give to the vault. A negative value
    means the vault pays the trader.
    """

    position_notional: str = betterproto.string_field(8)
    """
    The position's notional value after the position change, measured in quote
    units.
    """


@dataclass(eq=False, repr=False)
class MsgClosePosition(betterproto.Message):
    sender: str = betterproto.string_field(1)
    token_pair: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgClosePositionResponse(betterproto.Message):
    exchanged_notional_value: str = betterproto.string_field(1)
    """The amount of quote assets exchanged."""

    exchanged_position_size: str = betterproto.string_field(2)
    """The amount of base assets exchanged."""

    funding_payment: str = betterproto.string_field(3)
    """
    The funding payment applied on this position change, measured in quote
    units.
    """

    realized_pnl: str = betterproto.string_field(4)
    """
    The amount of PnL realized on this position changed, measured in quote
    units.
    """

    margin_to_trader: str = betterproto.string_field(7)
    """
    The amount of margin the trader receives after closing the position, from
    the vault. Should never be negative.
    """


@dataclass(eq=False, repr=False)
class MsgDonateToEcosystemFund(betterproto.Message):
    sender: str = betterproto.string_field(1)
    donation: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(2)
    """donation to the EF"""


@dataclass(eq=False, repr=False)
class MsgDonateToEcosystemFundResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class QueryPositionsRequest(betterproto.Message):
    """---------------------------------------- Positions"""

    trader: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryPositionsResponse(betterproto.Message):
    positions: List["QueryPositionResponse"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryPositionRequest(betterproto.Message):
    """
    QueryPositionRequest is the request type for the position of the x/perp
    module account.
    """

    token_pair: str = betterproto.string_field(1)
    trader: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryPositionResponse(betterproto.Message):
    position: "Position" = betterproto.message_field(1)
    """The position as it exists in the blockchain state"""

    position_notional: str = betterproto.string_field(2)
    """
    The position's current notional value, if it were to be entirely closed (in
    margin units).
    """

    unrealized_pnl: str = betterproto.string_field(3)
    """The position's unrealized PnL."""

    margin_ratio_mark: str = betterproto.string_field(4)
    """
    margin ratio of the position based on the mark price, mark TWAP. The higher
    value of the possible margin ratios (TWAP and instantaneous) is taken to be
    'marginRatioMark'. Calculated from margin, unrealized PnL, and position
    notional.
    """

    margin_ratio_index: str = betterproto.string_field(5)
    """
    margin ratio of the position based on the index price. Calculated from
    margin, unrealized PnL, and position notional.
    """

    block_number: int = betterproto.int64_field(7)
    """BlockNumber is current block number at the time of query."""


@dataclass(eq=False, repr=False)
class QueryCumulativePremiumFractionRequest(betterproto.Message):
    pair: str = betterproto.string_field(1)
    """the pair to query for"""


@dataclass(eq=False, repr=False)
class QueryCumulativePremiumFractionResponse(betterproto.Message):
    cumulative_premium_fraction: str = betterproto.string_field(1)
    """The latest cumulative premium fraction."""

    estimated_next_cumulative_premium_fraction: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryMetricsRequest(betterproto.Message):
    pair: str = betterproto.string_field(1)
    """the pair to query for"""


@dataclass(eq=False, repr=False)
class QueryMetricsResponse(betterproto.Message):
    metrics: "Metrics" = betterproto.message_field(1)
    """list of perp metrics"""


@dataclass(eq=False, repr=False)
class PositionChangedEvent(betterproto.Message):
    """
    Emitted when a position changes. TODO: Is there a way to split this into
    different events without creating too much complexity?
    """

    pair: str = betterproto.string_field(1)
    """identifier of the corresponding virtual pool for the position"""

    trader_address: str = betterproto.string_field(2)
    """owner of the position."""

    margin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(3)
    """
    Amount of collateral (quote units) backing the position after the change.
    """

    position_notional: str = betterproto.string_field(4)
    """
    Position notional (quote units) after the change. In general,  'notional =
    baseAmount * priceQuotePerBase', where size is the baseAmount.
    """

    exchanged_size: str = betterproto.string_field(5)
    """
    Exchanged size is the magnitude of the change to position size (base
    units).  The size is a signed quantity expressing how much exposure a
    position has in  base units of the pair.
    """

    exchanged_notional: str = betterproto.string_field(6)
    """
    * Exchanged notional is the value of the exchanged size in quote units.
    exchangedNotional = posBefore.OpenNotional + (direction * realizedPnl),
    where 'posBefore' is the position before the change, and  direction is 1 if
    posBefore.Size > 0 or -1 if posBefore.Size < 0,
    """

    transaction_fee: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(7)
    """Transaction fee paid. A "taker" fee."""

    position_size: str = betterproto.string_field(8)
    """Position size after the change."""

    realized_pnl: str = betterproto.string_field(9)
    """realize profits and losses after the change"""

    unrealized_pnl_after: str = betterproto.string_field(10)
    """unrealized profits and losses after the change"""

    bad_debt: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(11)
    """
    Amount of bad debt cleared by the PerpEF during the change.  Bad debt is
    negative net margin past the liquidation point of a position.
    """

    mark_price: str = betterproto.string_field(12)
    """
    Mark price, synonymous with mark price in this context, is the quotient of
    the quote reserves and base reserves
    """

    funding_payment: str = betterproto.string_field(13)
    """
    A funding payment made or received by the trader on the current position.
    'fundingPayment' is positive if 'owner' is the sender and negative if
    'owner'is the receiver of the payment. Its magnitude is abs(vSize *
    fundingRate). Funding payments act to converge the mark price (vPrice) and
    index price (average price on major exchanges).
    """

    block_height: int = betterproto.int64_field(14)
    """The block number at which this position was changed."""

    block_time_ms: int = betterproto.int64_field(15)
    """
    The block time in unix milliseconds at which this position was changed.
    """


@dataclass(eq=False, repr=False)
class PositionLiquidatedEvent(betterproto.Message):
    """Emitted when a position is liquidated."""

    pair: str = betterproto.string_field(1)
    """identifier of the corresponding virtual pool for the position"""

    trader_address: str = betterproto.string_field(2)
    """owner of the position."""

    exchanged_quote_amount: str = betterproto.string_field(3)
    """
    margin * leverage * vPrice. 'notional' is the virtual size times  the
    virtual price on 'vpool'.
    """

    exchanged_position_size: str = betterproto.string_field(4)
    """
    virtual amount of base assets for the position, which would be margin *
    leverage * priceBasePerQuote.
    """

    liquidator_address: str = betterproto.string_field(5)
    """Address of the account that executed the tx."""

    fee_to_liquidator: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(6)
    """Commission (in margin units) received by 'liquidator'."""

    fee_to_ecosystem_fund: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(
        7
    )
    """Commission (in margin units) given to the ecosystem fund."""

    bad_debt: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(8)
    """
    Bad debt (margin units) cleared by the PerpEF during the tx. Bad debt is
    negative net margin past the liquidation point of a position.
    """

    margin: "___cosmos_base_v1_beta1__.Coin" = betterproto.message_field(9)
    """Remaining margin in the position after liquidation"""

    position_notional: str = betterproto.string_field(10)
    """Remaining position notional in the position after liquidation"""

    position_size: str = betterproto.string_field(11)
    """Remaining position size in the position after liquidation"""

    unrealized_pnl: str = betterproto.string_field(12)
    """Unrealized PnL in the position after liquidation"""

    mark_price: str = betterproto.string_field(13)
    """Spot price of the vAMM after liquidation"""

    block_height: int = betterproto.int64_field(14)
    """The block number at which this liquidation occured."""

    block_time_ms: int = betterproto.int64_field(15)
    """
    The unix timestamp in milliseconds at which this liquidation occured.
    """


@dataclass(eq=False, repr=False)
class PositionSettledEvent(betterproto.Message):
    """Emitted when a position is settled."""

    pair: str = betterproto.string_field(1)
    """Identifier for the virtual pool of the position."""

    trader_address: str = betterproto.string_field(2)
    """Owner of the position."""

    settled_coins: List["___cosmos_base_v1_beta1__.Coin"] = betterproto.message_field(3)
    """Settled coin as dictated by the settlement price of the vpool."""


@dataclass(eq=False, repr=False)
class FundingRateChangedEvent(betterproto.Message):
    """Emitted when a new funding rate is calculated."""

    pair: str = betterproto.string_field(1)
    """The pair for which the funding rate was calculated."""

    mark_price: str = betterproto.string_field(2)
    """The mark price of the pair."""

    index_price: str = betterproto.string_field(3)
    """The oracle index price of the pair."""

    latest_funding_rate: str = betterproto.string_field(4)
    """The latest funding rate."""

    latest_premium_fraction: str = betterproto.string_field(5)
    """The latest premium fraction just calculated."""

    cumulative_premium_fraction: str = betterproto.string_field(6)
    """
    The latest cumulative premium fraction. The funding payment a position will
    pay is the difference between this value and the latest cumulative premium
    fraction on the position, multiplied by the position size.
    """

    block_height: int = betterproto.int64_field(7)
    """The block number at which the funding rate was calculated."""

    block_time_ms: int = betterproto.int64_field(8)
    """
    The block time in unix milliseconds at which the funding rate was
    calculated.
    """


@dataclass(eq=False, repr=False)
class MetricsEvent(betterproto.Message):
    pair: str = betterproto.string_field(1)
    net_size: str = betterproto.string_field(2)
    """Sum of all active position sizes for the pair."""

    volume_quote: str = betterproto.string_field(3)
    """Total notional volume for the pair."""

    volume_base: str = betterproto.string_field(4)
    """Total size volume for the pair."""

    block_height: int = betterproto.int64_field(5)
    """The block number at which metrics were generated."""

    block_time_ms: int = betterproto.int64_field(6)
    """The block time in unix milliseconds at which metrics were generated."""


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the perp module's genesis state."""

    params: "Params" = betterproto.message_field(1)
    pair_metadata: List["PairMetadata"] = betterproto.message_field(2)
    positions: List["Position"] = betterproto.message_field(3)
    prepaid_bad_debts: List["PrepaidBadDebt"] = betterproto.message_field(4)


class MsgStub(betterproto.ServiceStub):
    async def remove_margin(
        self,
        msg_remove_margin: "MsgRemoveMargin",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgRemoveMarginResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/RemoveMargin",
            msg_remove_margin,
            MsgRemoveMarginResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def add_margin(
        self,
        msg_add_margin: "MsgAddMargin",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgAddMarginResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/AddMargin",
            msg_add_margin,
            MsgAddMarginResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def liquidate(
        self,
        msg_liquidate: "MsgLiquidate",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgLiquidateResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/Liquidate",
            msg_liquidate,
            MsgLiquidateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def multi_liquidate(
        self,
        msg_multi_liquidate: "MsgMultiLiquidate",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgMultiLiquidateResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/MultiLiquidate",
            msg_multi_liquidate,
            MsgMultiLiquidateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def open_position(
        self,
        msg_open_position: "MsgOpenPosition",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgOpenPositionResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/OpenPosition",
            msg_open_position,
            MsgOpenPositionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def close_position(
        self,
        msg_close_position: "MsgClosePosition",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgClosePositionResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/ClosePosition",
            msg_close_position,
            MsgClosePositionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def donate_to_ecosystem_fund(
        self,
        msg_donate_to_ecosystem_fund: "MsgDonateToEcosystemFund",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDonateToEcosystemFundResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Msg/DonateToEcosystemFund",
            msg_donate_to_ecosystem_fund,
            MsgDonateToEcosystemFundResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_position(
        self,
        query_position_request: "QueryPositionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPositionResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Query/QueryPosition",
            query_position_request,
            QueryPositionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_positions(
        self,
        query_positions_request: "QueryPositionsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPositionsResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Query/QueryPositions",
            query_positions_request,
            QueryPositionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cumulative_premium_fraction(
        self,
        query_cumulative_premium_fraction_request: "QueryCumulativePremiumFractionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryCumulativePremiumFractionResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Query/CumulativePremiumFraction",
            query_cumulative_premium_fraction_request,
            QueryCumulativePremiumFractionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def metrics(
        self,
        query_metrics_request: "QueryMetricsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryMetricsResponse":
        return await self._unary_unary(
            "/nibiru.perp.v1.Query/Metrics",
            query_metrics_request,
            QueryMetricsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def remove_margin(
        self, msg_remove_margin: "MsgRemoveMargin"
    ) -> "MsgRemoveMarginResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_margin(
        self, msg_add_margin: "MsgAddMargin"
    ) -> "MsgAddMarginResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def liquidate(self, msg_liquidate: "MsgLiquidate") -> "MsgLiquidateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def multi_liquidate(
        self, msg_multi_liquidate: "MsgMultiLiquidate"
    ) -> "MsgMultiLiquidateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def open_position(
        self, msg_open_position: "MsgOpenPosition"
    ) -> "MsgOpenPositionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def close_position(
        self, msg_close_position: "MsgClosePosition"
    ) -> "MsgClosePositionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def donate_to_ecosystem_fund(
        self, msg_donate_to_ecosystem_fund: "MsgDonateToEcosystemFund"
    ) -> "MsgDonateToEcosystemFundResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_remove_margin(
        self, stream: "grpclib.server.Stream[MsgRemoveMargin, MsgRemoveMarginResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.remove_margin(request)
        await stream.send_message(response)

    async def __rpc_add_margin(
        self, stream: "grpclib.server.Stream[MsgAddMargin, MsgAddMarginResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_margin(request)
        await stream.send_message(response)

    async def __rpc_liquidate(
        self, stream: "grpclib.server.Stream[MsgLiquidate, MsgLiquidateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.liquidate(request)
        await stream.send_message(response)

    async def __rpc_multi_liquidate(
        self,
        stream: "grpclib.server.Stream[MsgMultiLiquidate, MsgMultiLiquidateResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.multi_liquidate(request)
        await stream.send_message(response)

    async def __rpc_open_position(
        self, stream: "grpclib.server.Stream[MsgOpenPosition, MsgOpenPositionResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.open_position(request)
        await stream.send_message(response)

    async def __rpc_close_position(
        self,
        stream: "grpclib.server.Stream[MsgClosePosition, MsgClosePositionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.close_position(request)
        await stream.send_message(response)

    async def __rpc_donate_to_ecosystem_fund(
        self,
        stream: "grpclib.server.Stream[MsgDonateToEcosystemFund, MsgDonateToEcosystemFundResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.donate_to_ecosystem_fund(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.perp.v1.Msg/RemoveMargin": grpclib.const.Handler(
                self.__rpc_remove_margin,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgRemoveMargin,
                MsgRemoveMarginResponse,
            ),
            "/nibiru.perp.v1.Msg/AddMargin": grpclib.const.Handler(
                self.__rpc_add_margin,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgAddMargin,
                MsgAddMarginResponse,
            ),
            "/nibiru.perp.v1.Msg/Liquidate": grpclib.const.Handler(
                self.__rpc_liquidate,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgLiquidate,
                MsgLiquidateResponse,
            ),
            "/nibiru.perp.v1.Msg/MultiLiquidate": grpclib.const.Handler(
                self.__rpc_multi_liquidate,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgMultiLiquidate,
                MsgMultiLiquidateResponse,
            ),
            "/nibiru.perp.v1.Msg/OpenPosition": grpclib.const.Handler(
                self.__rpc_open_position,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgOpenPosition,
                MsgOpenPositionResponse,
            ),
            "/nibiru.perp.v1.Msg/ClosePosition": grpclib.const.Handler(
                self.__rpc_close_position,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgClosePosition,
                MsgClosePositionResponse,
            ),
            "/nibiru.perp.v1.Msg/DonateToEcosystemFund": grpclib.const.Handler(
                self.__rpc_donate_to_ecosystem_fund,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDonateToEcosystemFund,
                MsgDonateToEcosystemFundResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def params(
        self, query_params_request: "QueryParamsRequest"
    ) -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_position(
        self, query_position_request: "QueryPositionRequest"
    ) -> "QueryPositionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_positions(
        self, query_positions_request: "QueryPositionsRequest"
    ) -> "QueryPositionsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cumulative_premium_fraction(
        self,
        query_cumulative_premium_fraction_request: "QueryCumulativePremiumFractionRequest",
    ) -> "QueryCumulativePremiumFractionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def metrics(
        self, query_metrics_request: "QueryMetricsRequest"
    ) -> "QueryMetricsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(
        self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    async def __rpc_query_position(
        self,
        stream: "grpclib.server.Stream[QueryPositionRequest, QueryPositionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_position(request)
        await stream.send_message(response)

    async def __rpc_query_positions(
        self,
        stream: "grpclib.server.Stream[QueryPositionsRequest, QueryPositionsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_positions(request)
        await stream.send_message(response)

    async def __rpc_cumulative_premium_fraction(
        self,
        stream: "grpclib.server.Stream[QueryCumulativePremiumFractionRequest, QueryCumulativePremiumFractionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.cumulative_premium_fraction(request)
        await stream.send_message(response)

    async def __rpc_metrics(
        self, stream: "grpclib.server.Stream[QueryMetricsRequest, QueryMetricsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.metrics(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/nibiru.perp.v1.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
            "/nibiru.perp.v1.Query/QueryPosition": grpclib.const.Handler(
                self.__rpc_query_position,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPositionRequest,
                QueryPositionResponse,
            ),
            "/nibiru.perp.v1.Query/QueryPositions": grpclib.const.Handler(
                self.__rpc_query_positions,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPositionsRequest,
                QueryPositionsResponse,
            ),
            "/nibiru.perp.v1.Query/CumulativePremiumFraction": grpclib.const.Handler(
                self.__rpc_cumulative_premium_fraction,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryCumulativePremiumFractionRequest,
                QueryCumulativePremiumFractionResponse,
            ),
            "/nibiru.perp.v1.Query/Metrics": grpclib.const.Handler(
                self.__rpc_metrics,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryMetricsRequest,
                QueryMetricsResponse,
            ),
        }
