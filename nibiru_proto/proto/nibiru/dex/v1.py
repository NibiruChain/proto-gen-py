# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: dex/v1/pool.proto, dex/v1/tx.proto, dex/v1/params.proto, dex/v1/query.proto, dex/v1/event.proto, dex/v1/genesis.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base import v1beta1
from .cosmos.base.query import v1beta1


class PoolType(betterproto.Enum):
    """
    - `balancer`: Balancer are pools defined by the equation xy=k, extended by
    the weighs introduced by Balancer. - `stableswap`: Stableswap pools are
    defined by a combination of constant-product and constant-sum pool
    """

    BALANCER = 0
    STABLESWAP = 1


@dataclass
class PoolParams(betterproto.Message):
    """Configuration parameters for the pool."""

    swap_fee: str = betterproto.string_field(1)
    exit_fee: str = betterproto.string_field(2)
    # Amplification Parameter (A): Larger value of A make the curve better
    # resemble a straight  line in the center (when pool is near balance).
    # Highly volatile assets should use a lower value, while assets that  are
    # closer together may be best with a higher value. This is only used if the
    # pool_type is set to 1 (stableswap)
    a: str = betterproto.string_field(3)
    pool_type: "PoolType" = betterproto.enum_field(4)


@dataclass
class PoolAsset(betterproto.Message):
    """Which assets the pool contains."""

    # Coins we are talking about, the denomination must be unique amongst all
    # PoolAssets for this pool.
    token: v1beta1.Coin = betterproto.message_field(1)
    # Weight that is not normalized. This weight must be less than 2^50
    weight: str = betterproto.string_field(2)


@dataclass
class Pool(betterproto.Message):
    # The pool id.
    id: int = betterproto.uint64_field(1)
    # The pool account address.
    address: str = betterproto.string_field(2)
    # Fees and other pool-specific parameters.
    pool_params: "PoolParams" = betterproto.message_field(3)
    # These are assumed to be sorted by denomiation. They contain the pool asset
    # and the information about the weight
    pool_assets: List["PoolAsset"] = betterproto.message_field(4)
    # sum of all non-normalized pool weights
    total_weight: str = betterproto.string_field(5)
    # sum of all LP tokens sent out
    total_shares: v1beta1.Coin = betterproto.message_field(6)


@dataclass
class MsgCreatePool(betterproto.Message):
    creator: str = betterproto.string_field(1)
    pool_params: "PoolParams" = betterproto.message_field(2)
    pool_assets: List["PoolAsset"] = betterproto.message_field(3)


@dataclass
class MsgCreatePoolResponse(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass
class MsgJoinPool(betterproto.Message):
    """
    Message to join a pool (identified by poolId) with a set of tokens to
    deposit.
    """

    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    tokens_in: List[v1beta1.Coin] = betterproto.message_field(3)
    use_all_coins: bool = betterproto.bool_field(4)


@dataclass
class MsgJoinPoolResponse(betterproto.Message):
    """Response when a user joins a pool."""

    # the final state of the pool after a join
    pool: "Pool" = betterproto.message_field(1)
    # sum of LP tokens minted from the join
    num_pool_shares_out: v1beta1.Coin = betterproto.message_field(2)
    # remaining tokens from attempting to join the pool
    remaining_coins: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class MsgExitPool(betterproto.Message):
    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    pool_shares: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class MsgExitPoolResponse(betterproto.Message):
    tokens_out: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class MsgSwapAssets(betterproto.Message):
    sender: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in: v1beta1.Coin = betterproto.message_field(3)
    token_out_denom: str = betterproto.string_field(4)


@dataclass
class MsgSwapAssetsResponse(betterproto.Message):
    token_out: v1beta1.Coin = betterproto.message_field(3)


@dataclass
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    # The start pool number, i.e. the first pool number that isn't taken yet.
    starting_pool_number: int = betterproto.uint64_field(1)
    # The cost of creating a pool, taken from the pool creator's account.
    pool_creation_fee: List[v1beta1.Coin] = betterproto.message_field(2)
    # The assets that can be used to create liquidity pools
    whitelisted_asset: List[str] = betterproto.string_field(3)


@dataclass
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    # params holds all the parameters of this module.
    params: "Params" = betterproto.message_field(1)


@dataclass
class QueryPoolNumberRequest(betterproto.Message):
    pass


@dataclass
class QueryPoolNumberResponse(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass
class QueryPoolRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass
class QueryPoolResponse(betterproto.Message):
    pool: "Pool" = betterproto.message_field(1)


@dataclass
class QueryPoolsRequest(betterproto.Message):
    # pagination defines an optional pagination for the request.
    pagination: v1beta1.PageRequest = betterproto.message_field(1)


@dataclass
class QueryPoolsResponse(betterproto.Message):
    pools: List["Pool"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: v1beta1.PageResponse = betterproto.message_field(2)


@dataclass
class QueryPoolParamsRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass
class QueryPoolParamsResponse(betterproto.Message):
    pool_params: "PoolParams" = betterproto.message_field(1)


@dataclass
class QueryNumPoolsRequest(betterproto.Message):
    pass


@dataclass
class QueryNumPoolsResponse(betterproto.Message):
    num_pools: int = betterproto.uint64_field(1)


@dataclass
class QueryTotalLiquidityRequest(betterproto.Message):
    """
    -------------------------------------------- Query total liquidity the
    protocol
    """

    pass


@dataclass
class QueryTotalLiquidityResponse(betterproto.Message):
    liquidity: List[v1beta1.Coin] = betterproto.message_field(1)


@dataclass
class QueryTotalPoolLiquidityRequest(betterproto.Message):
    """
    -------------------------------------------- Query total liquidity for a
    pool
    """

    pool_id: int = betterproto.uint64_field(1)


@dataclass
class QueryTotalPoolLiquidityResponse(betterproto.Message):
    liquidity: List[v1beta1.Coin] = betterproto.message_field(1)


@dataclass
class QueryTotalSharesRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass
class QueryTotalSharesResponse(betterproto.Message):
    # sum of all LP tokens sent out
    total_shares: v1beta1.Coin = betterproto.message_field(1)


@dataclass
class QuerySpotPriceRequest(betterproto.Message):
    """
    Returns the amount of tokenInDenom to produce 1 tokenOutDenom For example,
    if the price of NIBI = 9.123 NUSD, then setting tokenInDenom=NUSD and
    tokenOutDenom=NIBI would give "9.123".
    """

    pool_id: int = betterproto.uint64_field(1)
    # the denomination of the token you are giving into the pool
    token_in_denom: str = betterproto.string_field(2)
    # the denomination of the token you are taking out of the pool
    token_out_denom: str = betterproto.string_field(3)


@dataclass
class QuerySpotPriceResponse(betterproto.Message):
    spot_price: str = betterproto.string_field(1)


@dataclass
class QuerySwapExactAmountInRequest(betterproto.Message):
    """
    Given an exact amount of tokens in and a target tokenOutDenom, calculates
    the expected amount of tokens out received from a swap.
    """

    pool_id: int = betterproto.uint64_field(1)
    token_in: v1beta1.Coin = betterproto.message_field(2)
    token_out_denom: str = betterproto.string_field(3)


@dataclass
class QuerySwapExactAmountInResponse(betterproto.Message):
    token_out: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class QuerySwapExactAmountOutRequest(betterproto.Message):
    """
    Given an exact amount of tokens out and a target tokenInDenom, calculates
    the expected amount of tokens in required to do the swap.
    """

    pool_id: int = betterproto.uint64_field(1)
    token_out: v1beta1.Coin = betterproto.message_field(2)
    token_in_denom: str = betterproto.string_field(3)


@dataclass
class QuerySwapExactAmountOutResponse(betterproto.Message):
    token_in: v1beta1.Coin = betterproto.message_field(2)


@dataclass
class QueryJoinExactAmountInRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)
    tokens_in: List[v1beta1.Coin] = betterproto.message_field(2)


@dataclass
class QueryJoinExactAmountInResponse(betterproto.Message):
    # amount of pool shares returned to user after join
    pool_shares_out: str = betterproto.string_field(1)
    # coins remaining after pool join
    rem_coins: List[v1beta1.Coin] = betterproto.message_field(2)


@dataclass
class QueryJoinExactAmountOutRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass
class QueryJoinExactAmountOutResponse(betterproto.Message):
    pass


@dataclass
class QueryExitExactAmountInRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)
    # amount of pool shares to return to pool
    pool_shares_in: str = betterproto.string_field(2)


@dataclass
class QueryExitExactAmountInResponse(betterproto.Message):
    # coins obtained after exiting
    tokens_out: List[v1beta1.Coin] = betterproto.message_field(1)


@dataclass
class QueryExitExactAmountOutRequest(betterproto.Message):
    pool_id: int = betterproto.uint64_field(1)


@dataclass
class QueryExitExactAmountOutResponse(betterproto.Message):
    pass


@dataclass
class EventPoolJoined(betterproto.Message):
    address: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    tokens_in: List[v1beta1.Coin] = betterproto.message_field(3)
    pool_shares_out: v1beta1.Coin = betterproto.message_field(4)
    rem_coins: List[v1beta1.Coin] = betterproto.message_field(5)


@dataclass
class EventPoolCreated(betterproto.Message):
    creator: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)


@dataclass
class EventPoolExited(betterproto.Message):
    address: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    pool_shares_in: v1beta1.Coin = betterproto.message_field(3)
    tokens_out: List[v1beta1.Coin] = betterproto.message_field(4)


@dataclass
class EventAssetsSwapped(betterproto.Message):
    address: str = betterproto.string_field(1)
    pool_id: int = betterproto.uint64_field(2)
    token_in: v1beta1.Coin = betterproto.message_field(3)
    token_out: v1beta1.Coin = betterproto.message_field(4)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState defines the dex module's genesis state."""

    params: "Params" = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the Msg service."""

    async def create_pool(
        self,
        *,
        creator: str = "",
        pool_params: Optional["PoolParams"] = None,
        pool_assets: List["PoolAsset"] = [],
    ) -> MsgCreatePoolResponse:
        """Used to create a pool."""

        request = MsgCreatePool()
        request.creator = creator
        if pool_params is not None:
            request.pool_params = pool_params
        if pool_assets is not None:
            request.pool_assets = pool_assets

        return await self._unary_unary(
            "/nibiru.dex.v1.Msg/CreatePool",
            request,
            MsgCreatePoolResponse,
        )

    async def join_pool(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        tokens_in: List[v1beta1.Coin] = [],
        use_all_coins: bool = False,
    ) -> MsgJoinPoolResponse:
        """Join a pool as a liquidity provider."""

        request = MsgJoinPool()
        request.sender = sender
        request.pool_id = pool_id
        if tokens_in is not None:
            request.tokens_in = tokens_in
        request.use_all_coins = use_all_coins

        return await self._unary_unary(
            "/nibiru.dex.v1.Msg/JoinPool",
            request,
            MsgJoinPoolResponse,
        )

    async def exit_pool(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        pool_shares: Optional[v1beta1.Coin] = None,
    ) -> MsgExitPoolResponse:
        """Exit a pool position by returning LP shares"""

        request = MsgExitPool()
        request.sender = sender
        request.pool_id = pool_id
        if pool_shares is not None:
            request.pool_shares = pool_shares

        return await self._unary_unary(
            "/nibiru.dex.v1.Msg/ExitPool",
            request,
            MsgExitPoolResponse,
        )

    async def swap_assets(
        self,
        *,
        sender: str = "",
        pool_id: int = 0,
        token_in: Optional[v1beta1.Coin] = None,
        token_out_denom: str = "",
    ) -> MsgSwapAssetsResponse:
        """Swap assets in a pool"""

        request = MsgSwapAssets()
        request.sender = sender
        request.pool_id = pool_id
        if token_in is not None:
            request.token_in = token_in
        request.token_out_denom = token_out_denom

        return await self._unary_unary(
            "/nibiru.dex.v1.Msg/SwapAssets",
            request,
            MsgSwapAssetsResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query defines the gRPC querier service."""

    async def params(self) -> QueryParamsResponse:
        """Parameters of the dex module."""

        request = QueryParamsRequest()

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/Params",
            request,
            QueryParamsResponse,
        )

    async def pool_number(self) -> QueryPoolNumberResponse:
        """Next available pool id number."""

        request = QueryPoolNumberRequest()

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/PoolNumber",
            request,
            QueryPoolNumberResponse,
        )

    async def pool(self, *, pool_id: int = 0) -> QueryPoolResponse:
        """Fetch a pool by id."""

        request = QueryPoolRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/Pool",
            request,
            QueryPoolResponse,
        )

    async def pools(
        self, *, pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryPoolsResponse:
        """Returns all pools."""

        request = QueryPoolsRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/Pools",
            request,
            QueryPoolsResponse,
        )

    async def pool_params(self, *, pool_id: int = 0) -> QueryPoolParamsResponse:
        """Parameters of a single pool."""

        request = QueryPoolParamsRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/PoolParams",
            request,
            QueryPoolParamsResponse,
        )

    async def num_pools(self) -> QueryNumPoolsResponse:
        """Number of pools."""

        request = QueryNumPoolsRequest()

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/NumPools",
            request,
            QueryNumPoolsResponse,
        )

    async def total_liquidity(self) -> QueryTotalLiquidityResponse:
        """Total liquidity across all pools."""

        request = QueryTotalLiquidityRequest()

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/TotalLiquidity",
            request,
            QueryTotalLiquidityResponse,
        )

    async def total_pool_liquidity(
        self, *, pool_id: int = 0
    ) -> QueryTotalPoolLiquidityResponse:
        """Total liquidity in a single pool."""

        request = QueryTotalPoolLiquidityRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/TotalPoolLiquidity",
            request,
            QueryTotalPoolLiquidityResponse,
        )

    async def total_shares(self, *, pool_id: int = 0) -> QueryTotalSharesResponse:
        """Total shares in a single pool."""

        request = QueryTotalSharesRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/TotalShares",
            request,
            QueryTotalSharesResponse,
        )

    async def spot_price(
        self, *, pool_id: int = 0, token_in_denom: str = "", token_out_denom: str = ""
    ) -> QuerySpotPriceResponse:
        """Instantaneous price of an asset in a pool."""

        request = QuerySpotPriceRequest()
        request.pool_id = pool_id
        request.token_in_denom = token_in_denom
        request.token_out_denom = token_out_denom

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/SpotPrice",
            request,
            QuerySpotPriceResponse,
        )

    async def estimate_swap_exact_amount_in(
        self,
        *,
        pool_id: int = 0,
        token_in: Optional[v1beta1.Coin] = None,
        token_out_denom: str = "",
    ) -> QuerySwapExactAmountInResponse:
        """
        Estimates the amount of assets returned given an exact amount of tokens
        to swap.
        """

        request = QuerySwapExactAmountInRequest()
        request.pool_id = pool_id
        if token_in is not None:
            request.token_in = token_in
        request.token_out_denom = token_out_denom

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateSwapExactAmountIn",
            request,
            QuerySwapExactAmountInResponse,
        )

    async def estimate_swap_exact_amount_out(
        self,
        *,
        pool_id: int = 0,
        token_out: Optional[v1beta1.Coin] = None,
        token_in_denom: str = "",
    ) -> QuerySwapExactAmountOutResponse:
        """
        Estimates the amount of tokens required to return the exact amount of
        assets requested.
        """

        request = QuerySwapExactAmountOutRequest()
        request.pool_id = pool_id
        if token_out is not None:
            request.token_out = token_out
        request.token_in_denom = token_in_denom

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateSwapExactAmountOut",
            request,
            QuerySwapExactAmountOutResponse,
        )

    async def estimate_join_exact_amount_in(
        self, *, pool_id: int = 0, tokens_in: List[v1beta1.Coin] = []
    ) -> QueryJoinExactAmountInResponse:
        """
        Estimates the amount of pool shares returned given an amount of tokens
        to join.
        """

        request = QueryJoinExactAmountInRequest()
        request.pool_id = pool_id
        if tokens_in is not None:
            request.tokens_in = tokens_in

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateJoinExactAmountIn",
            request,
            QueryJoinExactAmountInResponse,
        )

    async def estimate_join_exact_amount_out(
        self, *, pool_id: int = 0
    ) -> QueryJoinExactAmountOutResponse:
        """
        Estimates the amount of tokens required to obtain an exact amount of
        pool shares.
        """

        request = QueryJoinExactAmountOutRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateJoinExactAmountOut",
            request,
            QueryJoinExactAmountOutResponse,
        )

    async def estimate_exit_exact_amount_in(
        self, *, pool_id: int = 0, pool_shares_in: str = ""
    ) -> QueryExitExactAmountInResponse:
        """
        Estimates the amount of tokens returned to the user given an exact
        amount of pool shares.
        """

        request = QueryExitExactAmountInRequest()
        request.pool_id = pool_id
        request.pool_shares_in = pool_shares_in

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateExitExactAmountIn",
            request,
            QueryExitExactAmountInResponse,
        )

    async def estimate_exit_exact_amount_out(
        self, *, pool_id: int = 0
    ) -> QueryExitExactAmountOutResponse:
        """
        Estimates the amount of pool shares required to extract an exact amount
        of tokens from the pool.
        """

        request = QueryExitExactAmountOutRequest()
        request.pool_id = pool_id

        return await self._unary_unary(
            "/nibiru.dex.v1.Query/EstimateExitExactAmountOut",
            request,
            QueryExitExactAmountOutResponse,
        )
