# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: cosmos/bank/v1beta1/bank.proto, cosmos/bank/v1beta1/tx.proto, cosmos/bank/v1beta1/query.proto, cosmos/bank/v1beta1/authz.proto, cosmos/bank/v1beta1/genesis.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base import v1beta1
from .cosmos.base.query import v1beta1


@dataclass
class Params(betterproto.Message):
    """Params defines the parameters for the bank module."""

    send_enabled: List["SendEnabled"] = betterproto.message_field(1)
    default_send_enabled: bool = betterproto.bool_field(2)


@dataclass
class SendEnabled(betterproto.Message):
    """
    SendEnabled maps coin denom to a send_enabled status (whether a denom is
    sendable).
    """

    denom: str = betterproto.string_field(1)
    enabled: bool = betterproto.bool_field(2)


@dataclass
class Input(betterproto.Message):
    """Input models transaction input."""

    address: str = betterproto.string_field(1)
    coins: List[v1beta1.Coin] = betterproto.message_field(2)


@dataclass
class Output(betterproto.Message):
    """Output models transaction outputs."""

    address: str = betterproto.string_field(1)
    coins: List[v1beta1.Coin] = betterproto.message_field(2)


@dataclass
class Supply(betterproto.Message):
    """
    Supply represents a struct that passively keeps track of the total supply
    amounts in the network. This message is deprecated now that supply is
    indexed by denom.
    """

    total: List[v1beta1.Coin] = betterproto.message_field(1)


@dataclass
class DenomUnit(betterproto.Message):
    """
    DenomUnit represents a struct that describes a given denomination unit of
    the basic token.
    """

    # denom represents the string name of the given denom unit (e.g uatom).
    denom: str = betterproto.string_field(1)
    # exponent represents power of 10 exponent that one must raise the base_denom
    # to in order to equal the given DenomUnit's denom 1 denom = 1^exponent
    # base_denom (e.g. with a base_denom of uatom, one can create a DenomUnit of
    # 'atom' with exponent = 6, thus: 1 atom = 10^6 uatom).
    exponent: int = betterproto.uint32_field(2)
    # aliases is a list of string aliases for the given denom
    aliases: List[str] = betterproto.string_field(3)


@dataclass
class Metadata(betterproto.Message):
    """Metadata represents a struct that describes a basic token."""

    description: str = betterproto.string_field(1)
    # denom_units represents the list of DenomUnit's for a given coin
    denom_units: List["DenomUnit"] = betterproto.message_field(2)
    # base represents the base denom (should be the DenomUnit with exponent = 0).
    base: str = betterproto.string_field(3)
    # display indicates the suggested denom that should be displayed in clients.
    display: str = betterproto.string_field(4)
    # name defines the name of the token (eg: Cosmos Atom) Since: cosmos-sdk 0.43
    name: str = betterproto.string_field(5)
    # symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
    # be the same as the display. Since: cosmos-sdk 0.43
    symbol: str = betterproto.string_field(6)


@dataclass
class MsgSend(betterproto.Message):
    """
    MsgSend represents a message to send coins from one account to another.
    """

    from_address: str = betterproto.string_field(1)
    to_address: str = betterproto.string_field(2)
    amount: List[v1beta1.Coin] = betterproto.message_field(3)


@dataclass
class MsgSendResponse(betterproto.Message):
    """MsgSendResponse defines the Msg/Send response type."""

    pass


@dataclass
class MsgMultiSend(betterproto.Message):
    """
    MsgMultiSend represents an arbitrary multi-in, multi-out send message.
    """

    inputs: List["Input"] = betterproto.message_field(1)
    outputs: List["Output"] = betterproto.message_field(2)


@dataclass
class MsgMultiSendResponse(betterproto.Message):
    """MsgMultiSendResponse defines the Msg/MultiSend response type."""

    pass


@dataclass
class QueryBalanceRequest(betterproto.Message):
    """
    QueryBalanceRequest is the request type for the Query/Balance RPC method.
    """

    # address is the address to query balances for.
    address: str = betterproto.string_field(1)
    # denom is the coin denom to query balances for.
    denom: str = betterproto.string_field(2)


@dataclass
class QueryBalanceResponse(betterproto.Message):
    """
    QueryBalanceResponse is the response type for the Query/Balance RPC method.
    """

    # balance is the balance of the coin.
    balance: v1beta1.Coin = betterproto.message_field(1)


@dataclass
class QueryAllBalancesRequest(betterproto.Message):
    """
    QueryBalanceRequest is the request type for the Query/AllBalances RPC
    method.
    """

    # address is the address to query balances for.
    address: str = betterproto.string_field(1)
    # pagination defines an optional pagination for the request.
    pagination: v1beta1.PageRequest = betterproto.message_field(2)


@dataclass
class QueryAllBalancesResponse(betterproto.Message):
    """
    QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
    method.
    """

    # balances is the balances of all the coins.
    balances: List[v1beta1.Coin] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: v1beta1.PageResponse = betterproto.message_field(2)


@dataclass
class QuerySpendableBalancesRequest(betterproto.Message):
    """
    QuerySpendableBalancesRequest defines the gRPC request structure for
    querying an account's spendable balances.
    """

    # address is the address to query spendable balances for.
    address: str = betterproto.string_field(1)
    # pagination defines an optional pagination for the request.
    pagination: v1beta1.PageRequest = betterproto.message_field(2)


@dataclass
class QuerySpendableBalancesResponse(betterproto.Message):
    """
    QuerySpendableBalancesResponse defines the gRPC response structure for
    querying an account's spendable balances.
    """

    # balances is the spendable balances of all the coins.
    balances: List[v1beta1.Coin] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: v1beta1.PageResponse = betterproto.message_field(2)


@dataclass
class QueryTotalSupplyRequest(betterproto.Message):
    """
    QueryTotalSupplyRequest is the request type for the Query/TotalSupply RPC
    method.
    """

    # pagination defines an optional pagination for the request. Since: cosmos-
    # sdk 0.43
    pagination: v1beta1.PageRequest = betterproto.message_field(1)


@dataclass
class QueryTotalSupplyResponse(betterproto.Message):
    """
    QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
    method
    """

    # supply is the supply of the coins
    supply: List[v1beta1.Coin] = betterproto.message_field(1)
    # pagination defines the pagination in the response. Since: cosmos-sdk 0.43
    pagination: v1beta1.PageResponse = betterproto.message_field(2)


@dataclass
class QuerySupplyOfRequest(betterproto.Message):
    """
    QuerySupplyOfRequest is the request type for the Query/SupplyOf RPC method.
    """

    # denom is the coin denom to query balances for.
    denom: str = betterproto.string_field(1)


@dataclass
class QuerySupplyOfResponse(betterproto.Message):
    """
    QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC
    method.
    """

    # amount is the supply of the coin.
    amount: v1beta1.Coin = betterproto.message_field(1)


@dataclass
class QueryParamsRequest(betterproto.Message):
    """
    QueryParamsRequest defines the request type for querying x/bank parameters.
    """

    pass


@dataclass
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse defines the response type for querying x/bank
    parameters.
    """

    params: "Params" = betterproto.message_field(1)


@dataclass
class QueryDenomsMetadataRequest(betterproto.Message):
    """
    QueryDenomsMetadataRequest is the request type for the Query/DenomsMetadata
    RPC method.
    """

    # pagination defines an optional pagination for the request.
    pagination: v1beta1.PageRequest = betterproto.message_field(1)


@dataclass
class QueryDenomsMetadataResponse(betterproto.Message):
    """
    QueryDenomsMetadataResponse is the response type for the
    Query/DenomsMetadata RPC method.
    """

    # metadata provides the client information for all the registered tokens.
    metadatas: List["Metadata"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: v1beta1.PageResponse = betterproto.message_field(2)


@dataclass
class QueryDenomMetadataRequest(betterproto.Message):
    """
    QueryDenomMetadataRequest is the request type for the Query/DenomMetadata
    RPC method.
    """

    # denom is the coin denom to query the metadata for.
    denom: str = betterproto.string_field(1)


@dataclass
class QueryDenomMetadataResponse(betterproto.Message):
    """
    QueryDenomMetadataResponse is the response type for the Query/DenomMetadata
    RPC method.
    """

    # metadata describes and provides all the client information for the
    # requested token.
    metadata: "Metadata" = betterproto.message_field(1)


@dataclass
class SendAuthorization(betterproto.Message):
    """
    SendAuthorization allows the grantee to spend up to spend_limit coins from
    the granter's account. Since: cosmos-sdk 0.43
    """

    spend_limit: List[v1beta1.Coin] = betterproto.message_field(1)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState defines the bank module's genesis state."""

    # params defines all the paramaters of the module.
    params: "Params" = betterproto.message_field(1)
    # balances is an array containing the balances of all the accounts.
    balances: List["Balance"] = betterproto.message_field(2)
    # supply represents the total supply. If it is left empty, then supply will
    # be calculated based on the provided balances. Otherwise, it will be used to
    # validate that the sum of the balances equals this amount.
    supply: List[v1beta1.Coin] = betterproto.message_field(3)
    # denom_metadata defines the metadata of the differents coins.
    denom_metadata: List["Metadata"] = betterproto.message_field(4)


@dataclass
class Balance(betterproto.Message):
    """
    Balance defines an account address and balance pair used in the bank
    module's genesis state.
    """

    # address is the address of the balance holder.
    address: str = betterproto.string_field(1)
    # coins defines the different coins this balance holds.
    coins: List[v1beta1.Coin] = betterproto.message_field(2)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the bank Msg service."""

    async def send(
        self,
        *,
        from_address: str = "",
        to_address: str = "",
        amount: List[v1beta1.Coin] = [],
    ) -> MsgSendResponse:
        """
        Send defines a method for sending coins from one account to another
        account.
        """

        request = MsgSend()
        request.from_address = from_address
        request.to_address = to_address
        if amount is not None:
            request.amount = amount

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Msg/Send",
            request,
            MsgSendResponse,
        )

    async def multi_send(
        self, *, inputs: List["Input"] = [], outputs: List["Output"] = []
    ) -> MsgMultiSendResponse:
        """
        MultiSend defines a method for sending coins from some accounts to
        other accounts.
        """

        request = MsgMultiSend()
        if inputs is not None:
            request.inputs = inputs
        if outputs is not None:
            request.outputs = outputs

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Msg/MultiSend",
            request,
            MsgMultiSendResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query defines the gRPC querier service."""

    async def balance(
        self, *, address: str = "", denom: str = ""
    ) -> QueryBalanceResponse:
        """
        Balance queries the balance of a single coin for a single account.
        """

        request = QueryBalanceRequest()
        request.address = address
        request.denom = denom

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Query/Balance",
            request,
            QueryBalanceResponse,
        )

    async def all_balances(
        self, *, address: str = "", pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryAllBalancesResponse:
        """
        AllBalances queries the balance of all coins for a single account.
        """

        request = QueryAllBalancesRequest()
        request.address = address
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Query/AllBalances",
            request,
            QueryAllBalancesResponse,
        )

    async def spendable_balances(
        self, *, address: str = "", pagination: Optional[v1beta1.PageRequest] = None
    ) -> QuerySpendableBalancesResponse:
        """
        SpendableBalances queries the spenable balance of all coins for a
        single account.
        """

        request = QuerySpendableBalancesRequest()
        request.address = address
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Query/SpendableBalances",
            request,
            QuerySpendableBalancesResponse,
        )

    async def total_supply(
        self, *, pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryTotalSupplyResponse:
        """TotalSupply queries the total supply of all coins."""

        request = QueryTotalSupplyRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Query/TotalSupply",
            request,
            QueryTotalSupplyResponse,
        )

    async def supply_of(self, *, denom: str = "") -> QuerySupplyOfResponse:
        """SupplyOf queries the supply of a single coin."""

        request = QuerySupplyOfRequest()
        request.denom = denom

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Query/SupplyOf",
            request,
            QuerySupplyOfResponse,
        )

    async def params(self) -> QueryParamsResponse:
        """Params queries the parameters of x/bank module."""

        request = QueryParamsRequest()

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Query/Params",
            request,
            QueryParamsResponse,
        )

    async def denom_metadata(self, *, denom: str = "") -> QueryDenomMetadataResponse:
        """
        DenomsMetadata queries the client metadata of a given coin
        denomination.
        """

        request = QueryDenomMetadataRequest()
        request.denom = denom

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Query/DenomMetadata",
            request,
            QueryDenomMetadataResponse,
        )

    async def denoms_metadata(
        self, *, pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryDenomsMetadataResponse:
        """
        DenomsMetadata queries the client metadata for all registered coin
        denominations.
        """

        request = QueryDenomsMetadataRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/cosmos.bank.v1beta1.Query/DenomsMetadata",
            request,
            QueryDenomsMetadataResponse,
        )
