"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.descriptor_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.extension_dict
import google.protobuf.message
import sys

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class ModuleDescriptor(google.protobuf.message.Message):
    """ModuleDescriptor describes an app module."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GO_IMPORT_FIELD_NUMBER: builtins.int
    USE_PACKAGE_FIELD_NUMBER: builtins.int
    CAN_MIGRATE_FROM_FIELD_NUMBER: builtins.int
    go_import: builtins.str
    """go_import names the package that should be imported by an app to load the
    module in the runtime module registry. It is required to make debugging
    of configuration errors easier for users.
    """
    @property
    def use_package(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PackageReference]:
        """use_package refers to a protobuf package that this module
        uses and exposes to the world. In an app, only one module should "use"
        or own a single protobuf package. It is assumed that the module uses
        all of the .proto files in a single package.
        """
    @property
    def can_migrate_from(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MigrateFromInfo]:
        """can_migrate_from defines which module versions this module can migrate
        state from. The framework will check that one module version is able to
        migrate from a previous module version before attempting to update its
        config. It is assumed that modules can transitively migrate from earlier
        versions. For instance if v3 declares it can migrate from v2, and v2
        declares it can migrate from v1, the framework knows how to migrate
        from v1 to v3, assuming all 3 module versions are registered at runtime.
        """
    def __init__(
        self,
        *,
        go_import: builtins.str = ...,
        use_package: collections.abc.Iterable[global___PackageReference] | None = ...,
        can_migrate_from: collections.abc.Iterable[global___MigrateFromInfo] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["can_migrate_from", b"can_migrate_from", "go_import", b"go_import", "use_package", b"use_package"]) -> None: ...

global___ModuleDescriptor = ModuleDescriptor

@typing_extensions.final
class PackageReference(google.protobuf.message.Message):
    """PackageReference is a reference to a protobuf package used by a module."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    REVISION_FIELD_NUMBER: builtins.int
    name: builtins.str
    """name is the fully-qualified name of the package."""
    revision: builtins.int
    """revision is the optional revision of the package that is being used.
    Protobuf packages used in Cosmos should generally have a major version
    as the last part of the package name, ex. foo.bar.baz.v1.
    The revision of a package can be thought of as the minor version of a
    package which has additional backwards compatible definitions that weren't
    present in a previous version.

    A package should indicate its revision with a source code comment
    above the package declaration in one of its files containing the
    text "Revision N" where N is an integer revision. All packages start
    at revision 0 the first time they are released in a module.

    When a new version of a module is released and items are added to existing
    .proto files, these definitions should contain comments of the form
    "Since Revision N" where N is an integer revision.

    When the module runtime starts up, it will check the pinned proto
    image and panic if there are runtime protobuf definitions that are not
    in the pinned descriptor which do not have
    a "Since Revision N" comment or have a "Since Revision N" comment where
    N is <= to the revision specified here. This indicates that the protobuf
    files have been updated, but the pinned file descriptor hasn't.

    If there are items in the pinned file descriptor with a revision
    greater than the value indicated here, this will also cause a panic
    as it may mean that the pinned descriptor for a legacy module has been
    improperly updated or that there is some other versioning discrepancy.
    Runtime protobuf definitions will also be checked for compatibility
    with pinned file descriptors to make sure there are no incompatible changes.

    This behavior ensures that:
    * pinned proto images are up-to-date
    * protobuf files are carefully annotated with revision comments which
      are important good client UX
    * protobuf files are changed in backwards and forwards compatible ways
    """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        revision: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "revision", b"revision"]) -> None: ...

global___PackageReference = PackageReference

@typing_extensions.final
class MigrateFromInfo(google.protobuf.message.Message):
    """MigrateFromInfo is information on a module version that a newer module
    can migrate from.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MODULE_FIELD_NUMBER: builtins.int
    module: builtins.str
    """module is the fully-qualified protobuf name of the module config object
    for the previous module version, ex: "cosmos.group.module.v1.Module".
    """
    def __init__(
        self,
        *,
        module: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["module", b"module"]) -> None: ...

global___MigrateFromInfo = MigrateFromInfo

MODULE_FIELD_NUMBER: builtins.int
module: google.protobuf.internal.extension_dict._ExtensionFieldDescriptor[google.protobuf.descriptor_pb2.MessageOptions, global___ModuleDescriptor]
"""module indicates that this proto type is a config object for an app module
and optionally provides other descriptive information about the module.
It is recommended that a new module config object and go module is versioned
for every state machine breaking version of a module. The recommended
pattern for doing this is to put module config objects in a separate proto
package from the API they expose. Ex: the cosmos.group.v1 API would be
exposed by module configs cosmos.group.module.v1, cosmos.group.module.v2, etc.
"""
